#!/usr/bin/env bash

################################################################################
# Git functions

function git_current_branch
{
    git rev-parse --abbrev-ref HEAD
}

function git_base_branch
{
    # Nearest branch in commit history

    base_branch=$( \
        git log --decorate --simplify-by-decoration --oneline | # selects only commits with a branch or tag
        grep -v "(HEAD"                                        | # removes current head (and branch)
        head -n1                                                | # selects only the closest decoration
        sed 's/.* (\(.*\)) .*/\1/'                               | # filters out everything but decorations
        sed -e 's/, /\n/g'                                        | # splits decorations
        grep -v 'tag:' | grep -vE '^origin\/' | grep -vE '\/HEAD$' | # ignore "tag: ...", "origin/..." and ".../HEAD"
        head -n1)                                                     # keep only first decoration

    # First possible merge base
    if [ -z "$base_branch" ]; then
        base_branch=$(git show-branch  --merge-base | head -n1)
    fi

    echo "$base_branch"
}

function git_commits
{
    local current_branch=${1:-$(git_current_branch)}
    local base_branch=${2:-$(git_base_branch)}

    git log --oneline --reverse --no-decorate "${base_branch}".."${current_branch}"
}

function git_titlize_branch
{
    local branch=${1:-$(git_current_branch)}

    # Split reference & label part

    local branch_split_pattern="^(.*)($JIRA_CODE_PATTERN)[^a-zA-Z0-9]?(.*)$"

    local title_ref;   title_ref=$(echo "$branch" | sed -r "s/$branch_split_pattern/\1\2/") # ex: 'feature/XY-1234'
    local title_label; title_label=$(echo "$branch" | sed -r "s/$branch_split_pattern/\3/") # ex: 'my-branch-name'

    # Uppercase 1st letters
    title_ref="${title_ref^}"
    title_label="${title_label^}"

    # substitute dashes & underscores
    title_label=$(echo "$title_label" | sed 's/[-_]/ /g')

    # Wip prefix
    local wip_prefix="WIP: "

    echo "${wip_prefix}${title_ref} ${title_label}"
}


################################################################################
# Misc. utilities

function exit_error
{
	local code=$1
	local msg="$2"

	echo_error "$msg"
	exit $code
}

function extract_json_string
{
    local key=$1
    local content=$2

    echo "$content" |
        grep -Po '"'"${key}"'"\s*:\s*"\K.*?[^\\]"' | # extract string
        sed 's/\\"/"/g' | # unescape double quotes
        sed 's/"$//' # remove trailing double quotes
}

function extract_json_int
{
    local key=$1
    local content=$2

    echo "$content" |
        grep -Po '"'"${key}"'"\s*:\s*\K.*?[,}]' | # extract int
        sed 's/[,}]$//' # remove trailing comma or brace
}

function extract_json_array
{
    local key=$1
    local content=$2

    echo "$content" |
        grep -Po '"'"${key}"'"\s*:\s*\[\K.*?[^\]]\]' | # extract array content
        sed 's/]$//' | # remove trailing bracket
        sed 's/"//g'   # remove double quotes
}

# https://gist.github.com/cdown/1163649
function urlencode
{
    old_lc_collate=$LC_COLLATE
    LC_COLLATE=C

    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "%s" "$c" ;;
            *) printf '%%%02X' "'$c" ;;
        esac
    done

    LC_COLLATE=$old_lc_collate
}

function colorize
{
    local input=$1

    if which tput > /dev/null 2>&1 && [ ! -z "$TERM" ] && [ "$(tput -T"$TERM" colors)" -ge 8 ]; then

        local bold='\e[1m'; local nobold='\e[21m'

        local red='\e[31m';    local lightred='\e[91m'
        local green='\e[32m';  local lightgreen='\e[92m'
        local orange='\e[33m'; local lightyellow='\e[93m'
        local blue='\e[34m';   local lightblue='\e[94m'
        local purple='\e[35m'; local lightpurple='\e[95m'
        local cyan='\e[36m';   local lightcyan='\e[96m'
        local gray='\e[090m';  local lightgray='\e[37m'

        local reset='\e[0m'

        for style in "${@:2}"; do
            echo -en "${!style}"
        done
        echo -en "$input"
        echo -en "$reset"

    else
        echo "$input"
    fi
}

function echo_error
{
    colorize "$1\n" "orange" >&2
}

function echo_debug
{
    if [ -z "$GIT_MR_VERBOSE" ]; then return; fi

    colorize "$1\n" "gray" >&2
}

function confirm
{
    local question=$1

    if [ "$GIT_MR_YES" = "1" ]; then
        echo_error "$(colorize "$question" "cyan") -> yes"
        echo "yes"
        return
    fi

    read -r -p "$(colorize "$question" "lightcyan" "bold") [y/N] " response
    case "$response" in
        [yY][eE][sS]|[yY]) echo "yes" ;;
        *)                 echo "no" ;;
    esac
}

function jq_build
{
    [ -x "$(command -v jq)" ] || exit_error 2 "jq is required for this operation"

    local key=${1}
    local value=${2}
    local initial_data=${3:-"{}"}

    local current_object;
    current_object="$(jq --null-input --compact-output \
        --arg value "$value"   "{\"${key}\": \$value}")"

    jq --null-input --compact-output \
            --argjson initial_data "$initial_data"     \
            --argjson current_object "$current_object" \
            '$initial_data + $current_object'
}

function open_in_browser
{
    local url=$1

    if [ -z "$url" ]; then
        return;
    fi

    if [ ! -x "$(command -v xdg-open)" ]; then
        echo "  ${url}"
        echo
        return;
    fi

    xdg-open "${url}" > /dev/null 2>&1
}


################################################################################
# Markdown formatting

function markdown_title
{
    local label=$1
    local level=${2:-1}

    for ((i=1; i<=level; i++)); do
        echo -n '#'
    done

    echo " ${label}"
}

function markdown_link
{
    local label=$1
    local url=$2

    if [ -z "$url" ]; then
        echo "[$label]"
        return
    fi

    echo "[$label]($url)"
}

function markdown_list
{
    local content=$1
    local wrap=$2

    local prefix="* ${wrap}"
    local suffix="${wrap}<br>"

    echo "$content" |
        sed "s/^/${prefix}/g" |
        sed "s/$/${suffix}/g"
}


################################################################################
# Jira functions

function jira_ticket_data
{
    [ ! -z "$JIRA_USER" ]     || exit_error 21 "JIRA_USER is not set"
    [ ! -z "$JIRA_TOKEN" ]    || exit_error 21 "JIRA_TOKEN is not set"
    [ ! -z "$JIRA_INSTANCE" ] || exit_error 21 "JIRA_INSTANCE is not set"

    local auth_token
    auth_token=$(echo -n "${JIRA_USER}:${JIRA_TOKEN}" | base64 -w 0)

    local issue_url="https://${JIRA_INSTANCE}/rest/api/3/issue/${1}?fields=summary"

    echo_debug "Jira - GET ${issue_url}"

    curl -Ss -X GET \
        --max-time ${GIT_MR_TIMEOUT:-5} \
        -H "Authorization: Basic ${auth_token}" \
        -H "Content-Type: application/json" \
        "${issue_url}" || exit_error 20 "Jira request error"
}


################################################################################
# Gitlab functions

function gitlab_check_env
{
    [ ! -z "$GITLAB_DOMAIN" ] || exit_error 11 "GITLAB_DOMAIN is not set"
    [ ! -z "$GITLAB_TOKEN" ]  || exit_error 11 "GITLAB_TOKEN is not set"
}

function gitlab_project_url
{
    gitlab_check_env

    local project_url

    project_url=$(git remote get-url --push origin |
        grep "${GITLAB_DOMAIN}" |
        sed "s/git\@${GITLAB_DOMAIN}:\(.*\).git/\1/")

    if [ -z "$project_url" ]; then
        local remote=$(git remote get-url --push origin)
        local domain=$(echo $remote | sed 's/.*@\(.*\):.*/\1/')
        read -r -d '' message <<EOF
Unable to determine Gitlab project URL, check GITLAB_DOMAIN configuration
  origin:     $remote
  current:    GITLAB_DOMAIN="$GITLAB_DOMAIN"
  Suggestion: GITLAB_DOMAIN="$domain"
EOF
        exit_error 12 "$message" # Unable to determine Gitlab project URL
    fi

    echo "$project_url"
}

function gitlab_request
{
    gitlab_check_env

    local project_url; project_url=$(gitlab_project_url) || exit $?
    local project_id;  project_id=$(urlencode "$project_url")

    if [ -z "$project_id" ]; then return; fi

    local gitlab_base_url="https://${GITLAB_DOMAIN}/api/v4"

    local gitlab_project_url="${gitlab_base_url}/projects/${project_id}"

    local request_url=$1
    local request_verb=${2:-"GET"}
    local request_data=${3}

    echo_debug "GitLab - $request_verb $request_url"

    result=$(curl -Ss \
        -X "${request_verb}" \
        -H "Private-Token: ${GITLAB_TOKEN}" \
        -H "Content-Type: application/json" \
        --data "${request_data}" \
        --max-time ${GIT_MR_TIMEOUT:-5} \
        "${gitlab_project_url}/${request_url}") || exit_error 10 "Gitlab request error"

    if [ ! -z "$(gitlab_check_error "$result")" ]; then return; fi

    echo "$result"
}

function gitlab_check_error
{
    local result=$1

    local error;   error=$(extract_json_string "error" "${result}")
    local message; message=$(extract_json_string "message" "${result}")

    if [ ! -z "$error" ] || [ ! -z "$message" ]; then
        echo_error "\nGitlab error:\n  ${result}"

        echo "ko"
    fi
}

function gitlab_new_merge_request_url
{
    gitlab_check_env

    local project_url;   project_url=$(gitlab_project_url) || exit $?

    if [ -z "$project_url" ]; then return; fi

    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-$(git_base_branch)}

    local gitlab_mr_url="https://${GITLAB_DOMAIN}/${project_url}/merge_requests/new"

    gitlab_mr_url="${gitlab_mr_url}?$(urlencode "merge_request[source_branch]")=${source_branch}"
    gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[target_branch]")=${target_branch}"

    # default labels
    for label_id in $(gitlab_default_label_ids); do
        gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[label_ids][]")=${label_id}"
    done

    # other options
    if [ "${GITLAB_DEFAULT_FORCE_REMOVE_SOURCE_BRANCH:-1}" -eq 1 ]; then
        gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[force_remove_source_branch]")=1"
    fi

    # title
    local title
    title=$(git_titlize_branch "$source_branch")
    title=$(urlencode "$title")
    gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[title]")=${title}"

    echo "$gitlab_mr_url"
}

function gitlab_merge_requests
{
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    local result
    result=$(gitlab_request "merge_requests?state=opened&view=simple&source_branch=${source_branch}") || exit $?

    if [ -z "$result" ] || [ "$result" = "[]" ]; then
        return
    fi

    echo "$result"
}

function gitlab_merge_request
{
    gitlab_check_env

    local mr_iid=$1

    if [ -z "$mr_iid" ]; then return; fi

    gitlab_request "merge_requests/$mr_iid"
}

function gitlab_extract_url
{
    local mr_summary=$1

    extract_json_string "web_url" "${mr_summary}"
}

function gitlab_extract_title
{
    local mr_summary=$1

    extract_json_string "title" "$mr_summary" |
        sed 's/\\u003c/</g' |
        sed 's/\\u003e/>/g' |
        sed 's/\\\\/\\/g'
}

function gitlab_extract_description
{
    local mr_detail=$1

    extract_json_string "description" "$mr_detail" |
        sed 's/\\r//g' |
        sed 's/\\n/\n/g' |
        sed 's/\\u003c/</g' |
        sed 's/\\u003e/>/g' |
        sed 's/\\\\/\\/g'
}

function gitlab_merge_request_discussions
{
    gitlab_check_env

    local mr_iid=$1

    if [ -z "$mr_iid" ]; then return; fi

    local notes
    local per_page=100
    local page=1
    local notes_page_count=${per_page}

    while [ "$notes_page_count" -eq "$per_page" ]; do

        # fetch page
        local notes_page
        notes_page=$(gitlab_request "merge_requests/$mr_iid/discussions?per_page=${per_page}&page=${page}" |
            sed 's/\\r//g' |
            sed 's/\\n/\\\\n/g' |
            sed 's/"noteable_iid":\([0-9]*\)}]},/"noteable_iid":\1}]},\n/g')

        if [ "$notes_page" != "[]" ]; then
            # append page
            if [ ! -z "$notes" ]; then
                notes=$(echo -e "${notes}\n,") # 1 character after new line avoids trimming
            fi
            notes="${notes}${notes_page}"

            # increment
            notes_page_count=$(echo -e "$notes_page" | wc -l)
            page=$((page+1))
        else
            notes_page_count=0
        fi
    done

    echo "$notes"
}

function gitlab_default_label_ids
{
    gitlab_check_env

    local gitlab_labels; gitlab_labels=$(gitlab_request "labels")

    # split in multiple lines
    gitlab_labels=$(echo "$gitlab_labels" | sed "s/},/},\n/g")

    # extact ids
    oIFS="$IFS"; IFS=','; read -ra default_labels <<< "$GITLAB_DEFAULT_LABELS"; IFS="$oIFS"; unset oIFS
    for label in "${default_labels[@]}"; do

        local label_row; label_row=$(echo "$gitlab_labels" | grep "\"name\":\"$label\"")
        local label_id;  label_id=$(extract_json_int "id" "$label_row")

        if [ ! -z "$label_id" ]; then
            echo "$label_id"
        fi
    done
}

function gitlab_merge_request_update
{
    gitlab_check_env

    local mr_iid=$1;   if [ -z "$mr_iid" ];  then echo_error "No mr_iid provided"; return; fi
    local mr_data=$2;  if [ -z "$mr_data" ]; then echo_error "No data provided";   return; fi

    gitlab_request "merge_requests/${mr_iid}" "PUT" "${mr_data}"
}

function gitlab_merge_request_merge
{
    gitlab_check_env

    local mr_iid=$1;  if [ -z "$mr_iid" ]; then echo_error "No mr_iid provided"; return; fi

    gitlab_request "merge_requests/${mr_iid}/merge?should_remove_source_branch=${GITLAB_DEFAULT_FORCE_REMOVE_SOURCE_BRANCH:-1}" "PUT"
}

function gitlab_unwip
{
    gitlab_check_env

    local current_branch; current_branch=$(git_current_branch)
    local base_branch;    base_branch=$(git_base_branch)

    # Search existing merge request

    local mr_summary; mr_summary=$(gitlab_merge_requests "$current_branch") || exit $?
    local mr_iid;     mr_iid=$(extract_json_int "iid" "$mr_summary")
    local mr_url;     mr_url=$(gitlab_extract_url "$mr_summary")

    if [ -z "${mr_iid}" ] || [ -z "${mr_url}" ]; then
        echo_error "Merge request not found"
        mr_print "$(guess_issue_code)" "${base_branch}"
        return
    fi

    # Load existing merge request details

    local merge_request; merge_request=$(gitlab_merge_request "$mr_iid")
    local mr_title;      mr_title=$(gitlab_extract_title "$merge_request")

    echo
    echo "-------------------------------------------------------------------"
    echo "$mr_title"
    echo "-------------------------------------------------------------------"
    echo
    mr_actions "$current_branch" "$base_branch" "$mr_summary" "$merge_request"
    echo

    local wip; wip=$(echo "$mr_title" | grep -o '^WIP:')
    if [ -z "$wip" ]; then
        echo_error "Merge request is not a Work in Progress"
        echo_error
        return
    fi

    local unwipped_title; unwipped_title=$(echo "$mr_title" | sed 's/^WIP:\s*//')

    if [ "$(confirm "Do you want to resolve WIP status?")" = "yes" ]; then
        echo -n "Resolving WIP status... "

        mr_data=$(jq_build "title" "$unwipped_title") || exit $?
        local result; result=$(gitlab_merge_request_update "${mr_iid}" "${mr_data}")

        if [ ! -z "$result" ]; then echo -e "OK\n"; fi
    fi

    echo
}


################################################################################
# Merge request utility functions

function guess_issue_code
{
    [ ! -z "$JIRA_CODE_PATTERN" ] || exit_error 0 "JIRA_CODE_PATTERN not set - unable to guess issue code"

    local current_branch; current_branch=$(git_current_branch)

    local issue_code; issue_code=$(echo "${current_branch}" |
        grep -iEo "$JIRA_CODE_PATTERN" |
        tail -n1)

    if [ -z "$issue_code" ]; then
        echo_error "Unable to guess issue code"
        return
    fi

    echo "$issue_code"
}

function mr_title
{
    local current_branch=${1:-$(git_current_branch)}

    if [ -z "$ISSUE_CODE" ]; then
        echo "$current_branch"
        return
    fi

    local issue_content; issue_content=$(jira_ticket_data "$ISSUE_CODE")

    local issue_key;     issue_key=$(extract_json_string "key" "$issue_content")
    local issue_title;   issue_title=$(extract_json_string "summary" "$issue_content")

    if [ -z "$issue_key" ]; then
        issue_key=${ISSUE_CODE^^}
    fi

    if [ -z "$issue_title" ]; then
        echo_error "Unable to get issue title from Jira"
        echo_error "  ISSUE_CODE: $ISSUE_CODE"
        if [ ! -z "$issue_content" ]; then
            echo_error "  $issue_content"
        fi

        echo "$issue_key"
        return
    fi

    issue_url="https://${JIRA_INSTANCE}/browse/${issue_key}"

    markdown_link "${issue_key} ${issue_title}" "$issue_url"
}

function mr_description
{
    local current_branch=${1:-$(git_current_branch)}
    local base_branch=${2:-$(git_base_branch)}

    local title;   title=$(mr_title "$current_branch") || exit $?
    local commits; commits=$(git_commits "$current_branch" "$base_branch")

    cat << EOF

--------------------------------------------------------------------------------
$(markdown_title "$title")


## Commits

$(markdown_list "$commits" "**")

--------------------------------------------------------------------------------

EOF
}

function mr_actions
{
    local current_branch=${1:-$(git_current_branch)}
    local base_branch=${2:-$(git_base_branch)}
    local mr_summary=${3}
    local mr_detail=${4}

    if [ -z "$mr_summary" ]; then
        mr_summary=$(gitlab_merge_requests "$current_branch") || exit $?
    fi

    local mr_iid; mr_iid=$(extract_json_int "iid" "${mr_summary}")
    local mr_url; mr_url=$(gitlab_extract_url "$mr_summary")

    if [ ! -z "${mr_url}" ]; then
        cat << EOF
Merge request:

  ${mr_url}
EOF
        mr_status "${mr_iid}" "$mr_detail"
        return
    fi

    local new_mr_url
    new_mr_url=$(gitlab_new_merge_request_url "${current_branch}" "${base_branch}")

    cat << EOF
To create a new merge request:

  ${new_mr_url}

EOF
}

function is_status_label
{
    local label=$1

    local system_labels=$(echo "${GITLAB_OK_LABELS},${GITLAB_CR_LABELS},${GITLAB_QA_LABELS}" |
        sed 's/,,/,/g' |
        sed 's/^,//' | sed 's/,$//' |
        tr "," "\n")

    match="$( echo "$label"         | grep "$system_labels")" || return
    reverse=$(echo "$system_labels" | grep "$match")          || return
    # reverse-match is important, we don't want "Jean-Pierre BACRI Team" to match "CR" label

    echo "$match"
}

function mr_format_labels
{
    local labels=$1

    IFS=',' read -r -a labels_array <<< "$labels"

    local status_labels=()
    local other_labels=()

    for label in "${labels_array[@]}"; do
        if [ ! -z "$(is_status_label "$label")" ]; then
            status_labels+=($(colorize "[$label]" "lightpurple" "bold"))
        else
            other_labels+=("[$label]")
        fi
    done

    local status_labels_str="$(printf "%s " "${status_labels[@]}")"
    local other_labels_str="$(printf "%s " "${other_labels[@]}")"

    echo "${status_labels_str}${other_labels_str}" |
        sed 's/^\s*//' | sed 's/\s*$//' # remove leading and trailing spaces
}

function mr_status
{
    local mr_iid=$1

    [ ! -z "$mr_iid" ] || exit_error 0 "mr_iid not provided"

    local merge_request; merge_request=${2:-$(gitlab_merge_request "$mr_iid")}

    # Labels
    local labels; labels=$(extract_json_array "labels" "$merge_request")
    local labels_display=$(mr_format_labels "$labels")

    # Votes

    local upvotes;   upvotes=$(extract_json_int "upvotes" "$merge_request")
    local downvotes; downvotes=$(extract_json_int "downvotes" "$merge_request")

    if [ "$upvotes" -gt 1 ];   then upvotes=$(colorize "$upvotes" "bold" "lightgreen")
    elif [ "$upvotes" -gt 0 ]; then upvotes=$(colorize "$upvotes" "bold" "lightyellow")
                               else upvotes=$(colorize "$upvotes" "bold"); fi

    if [ "$downvotes" -gt 0 ];
        then downvotes=$(colorize "$downvotes" "bold" "lightred")
        else downvotes=$(colorize "$downvotes" "bold"); fi

    # Threads

    local notes;          notes=$(gitlab_merge_request_discussions "$mr_iid")
    local thread_count;   thread_count=$(echo "$notes" | grep -c '"resolvable":true')
    local resolved_count; resolved_count=$(echo "$notes" | grep -c '"resolved":true')

    local thread_count_display;
        thread_count_display=$(colorize "$thread_count" "bold")

    local resolved_count_display; if [ "$resolved_count" -lt "$thread_count" ];
        then resolved_count_display=$(colorize "$resolved_count" "bold" "lightred")
        else resolved_count_display=$(colorize "$resolved_count" "bold" "lightgreen"); fi

    # WiP
    local title; title=$(gitlab_extract_title "$merge_request")
    local wip;   wip=$(echo "$title" | grep -o '^WIP:')

    # Merge status
    local merge_status; merge_status=$(extract_json_string "merge_status" "$merge_request")
    local merge_status_icon; if [ "$merge_status" = "can_be_merged" ];
        then merge_status_icon="$(colorize "\U00002714" "lightgreen" "bold")"; # heavy check mark
        else merge_status_icon="$(colorize "\U0000274C" "lightred" "bold")"; fi # cross mark

    # Display
    echo
    echo -e  "   \U0001F3F7  ${labels_display}\n"
    echo -en "   \U0001F44D  ${upvotes}"
    echo -en "   \U0001F44E  ${downvotes}"
    if [ "$thread_count" -gt 0 ]; then
        echo -n "      Resolved threads: ${resolved_count_display}/${thread_count_display}"
    fi
    if [ ! -z "$wip" ]; then
        echo -en "      WIP: $(colorize "yes" "orange")"
    fi
    echo -en "      Can be merged: ${merge_status_icon}"
    echo -e "\n"
}


################################################################################
# Merge request top-level functions

function mr_print
{
    ISSUE_CODE=${1:-$(guess_issue_code)}

    local current_branch; current_branch=$(git_current_branch)
    local base_branch=${2:-$(git_base_branch)}

    mr_description "$current_branch" "$base_branch"
    mr_actions     "$current_branch" "$base_branch"
}

function mr_open
{
    local current_branch; current_branch=$(git_current_branch)
    local base_branch;    base_branch=${2:-$(git_base_branch)}

    local mr_summary; mr_summary=$(gitlab_merge_requests "$current_branch")
    local mr_iid;     mr_iid=$(extract_json_int "iid" "${mr_summary}")
    local mr_url;     mr_url=$(gitlab_extract_url "$mr_summary")

    if [ ! -z "${mr_url}" ]; then
        mr_status "${mr_iid}"
        open_in_browser "${mr_url}"
        return
    fi

    ISSUE_CODE=${1:-$(guess_issue_code)}
    mr_description "$current_branch" "$base_branch"

    local new_mr_url; new_mr_url=$(gitlab_new_merge_request_url "${current_branch}" "${base_branch}")

    if [ ! -z "${new_mr_url}" ]; then
        open_in_browser "${new_mr_url}"
    fi
}

function mr_update
{
    gitlab_check_env

    local current_branch; current_branch=$(git_current_branch)
    local base_branch;    base_branch=${1:-$(git_base_branch)}

    # Search existing merge request

    local mr_summary; mr_summary=$(gitlab_merge_requests "$current_branch") || exit $?
    local mr_iid;     mr_iid=$(extract_json_int "iid" "$mr_summary")
    local mr_url;     mr_url=$(gitlab_extract_url "$mr_summary")

    if [ -z "${mr_iid}" ] || [ -z "${mr_url}" ]; then
        echo_error "Merge request not found"
        mr_print "$(guess_issue_code)" "${base_branch}"
        return
    fi

    # Load existing merge request details

    local merge_request;  merge_request=$(gitlab_merge_request "$mr_iid")
    local mr_title;       mr_title=$(gitlab_extract_title "$merge_request")
    local mr_description; mr_description=$(gitlab_extract_description "$merge_request")
    local current_target; current_target=$(extract_json_string "target_branch" "$merge_request")

    # Init commit lists

    local commit_messages; commit_messages=$(git_commits "$current_branch" "$base_branch")

    local current_commits; current_commits=$(echo "$commit_messages" | cut -d ' ' -f1)
    local old_commits;     old_commits=$(echo "$mr_description" |
        grep -Po '^[^0-9a-fA-F]*[0-9a-fA-F]{7,}\s' |
        sed -r 's/^[^0-9a-fA-F]*([0-9a-fA-F]{7,})\s/\1/g')

    local current_commits_array; current_commits_array=($(echo "$current_commits" | tr "\n" " "))
    local old_commits_array;     old_commits_array=($(echo "$old_commits" | tr "\n" " "))

    local updated_commit_count=0
    local new_commit_messages_display=()
    local new_commit_messages_content=()

    local new_description_display="$mr_description"
    local new_description_content="$mr_description"

    local sameColor="lightblue"
    local updatedColor="orange"
    local newColor="green"

    # Iterate over commit lists, compare sha-1 and update description
    for i in ${!current_commits_array[*]}; do

        local curr=${current_commits_array[$i]}
        local old=${old_commits_array[$i]}

        if [ ! -z "$old" ]; then
            if [ "$old" = "$curr" ]; then
                # same sha-1 - only decorate
                new_description_display=$(echo "$new_description_display" | sed "s/$old/$(colorize "$curr" "$sameColor")/")
                new_description_content=$(echo "$new_description_content" | sed "s/$old/$curr/" )
            else
                # different sha-1 - replace & decorate
                new_description_display=$(echo "$new_description_display" | sed "s/$old/$(colorize "$curr" "$updatedColor")/")
                new_description_content=$(echo "$new_description_content" | sed "s/$old/$curr/" )
                updated_commit_count=$((updated_commit_count+1))
            fi
        else
            # new commits
            new_commit_messages_display+=("$(echo "$commit_messages" | grep "$curr" | sed "s/$curr/$(colorize "$curr" "$newColor")/")")
            new_commit_messages_content+=("$(echo "$commit_messages" | grep "$curr")")
        fi
    done

    local new_commit_count=${#new_commit_messages_display[@]}

    # implode arrays
    local new_commit_messages_display_str; new_commit_messages_display_str=$(printf "%s\n" "${new_commit_messages_display[@]}")
    local new_commit_messages_content_str; new_commit_messages_content_str=$(printf "%s\n" "${new_commit_messages_content[@]}")

    # Print updated merge request description
    echo
    echo "-------------------------------------------------------------------"
    echo "$mr_title"
    echo "-------------------------------------------------------------------"
    echo "$new_description_display"
    echo
    echo
    if [ "$new_commit_count" -gt 0 ]; then
        echo "## Update"
        echo
        echo "$(markdown_list "$new_commit_messages_display_str" "**")"
        echo
    fi
    echo "--------------------------------------------------------------------------------"
    echo
    echo "  updated commits: $(colorize "$updated_commit_count" "$updatedColor")"
    echo "      new commits: $(colorize "$new_commit_count"     "$newColor")"
    echo

    # Propose update if changes are detected

    if [ ! -x "$(command -v jq)" ]; then
        echo_error "Please install jq to be able to update merge request"

    else
        local mr_update_data='{}'

        if [ $((updated_commit_count + new_commit_count)) -gt 0 ] \
        && [ "$(confirm "Do you want to update the merge request description?")" = "yes" ]; then
            echo -n "Updating merge request description... "

            local new_description
            new_description=$(echo -e "${new_description_content}")

            if [ "$new_commit_count" -gt 0 ]; then
                new_description=$(echo -e "${new_description}\n\n## Update")
                new_description=$(echo -e "${new_description}\n\n$(markdown_list "$new_commit_messages_content_str" "**")")
            fi
            new_description=$(echo -e "${new_description}\n ")

            mr_update_data=$(jq_build "description" "$new_description" "$mr_update_data") || exit $?
        fi

        if [ "$base_branch" != "$current_target" ] \
        && [ "$(confirm "Do you want to update the merge request target branch from '$current_target' to '$base_branch'?")" = "yes" ]; then
            mr_update_data=$(jq_build "target_branch" "$base_branch" "$mr_update_data") || exit $?
        fi

        if [ "$mr_update_data" != "{}" ]; then
            local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_update_data")

            if [ ! -z "$result" ]; then echo -e "OK\n"; fi
        fi
    fi

    echo "--------------------------------------------------------------------------------"
    echo

    mr_actions "$current_branch" "$base_branch" "$mr_summary" "$merge_request"
}

function mr_merge
{
    gitlab_check_env

    local gitlab_base_url="https://${GITLAB_DOMAIN}/api/v4"

    local current_branch; current_branch=$(git_current_branch)
    local base_branch;    base_branch=${1:-$(git_base_branch)}

    # Search existing merge request

    local mr_summary; mr_summary=$(gitlab_merge_requests "$current_branch") || exit $?
    local mr_iid;     mr_iid=$(extract_json_int "iid" "$mr_summary")
    local mr_url;     mr_url=$(gitlab_extract_url "$mr_summary")

    if [ -z "${mr_iid}" ] || [ -z "${mr_url}" ]; then
        echo_error "Merge request not found"
        mr_print "$(guess_issue_code)" "${base_branch}"
        return
    fi

    # Load existing merge request details

    local merge_request; merge_request=$(gitlab_merge_request "$mr_iid")
    local title;         title=$(gitlab_extract_title "$merge_request")
    local merge_status;  merge_status=$(extract_json_string "merge_status" "$merge_request")

    echo
    echo "-------------------------------------------------------------------"
    echo "$title"
    echo "-------------------------------------------------------------------"
    echo
    mr_actions "$current_branch" "$base_branch" "$mr_summary" "$merge_request"

    # test merge status
    if [ "$merge_status" != "can_be_merged" ]; then
        echo_error "Merge request can not be merged. You probably need to rebase the branch and resolve conflicts."
        echo_error
        return
    fi

    # test open threads
    local unresolved_thread_count;
    unresolved_thread_count=$(gitlab_merge_request_discussions "$mr_iid" |
        grep '"resolvable":true' |
        grep -c '"resolved":false')

    if [ "$unresolved_thread_count" -gt 0 ]; then
        echo_error "There are $unresolved_thread_count unresolved threads. Please resolve them before merging."
        echo_error
        return
    fi

    # test WIP status
    local wip; wip=$(echo "$title" | grep -o '^WIP:')

    if [ ! -z "$wip" ]; then
        echo_error "Merge request is a Work in Progress"
        if [ "$(confirm "Do you want to resolve WIP status?")" = "yes" ]; then
            echo -n "Resolving WIP status... "

            local unwipped_title; unwipped_title=$(echo "$title" | sed 's/^WIP:\s*//')
            local mr_data;        mr_data=$(jq_build "title" "$unwipped_title") || exit $?

            local result; result=$(gitlab_merge_request_update "${mr_iid}" "${mr_data}")

            if [ ! -z "$result" ]; then echo -e "OK\n";
            else echo_error; return; fi
        else
            echo_error; return;
        fi
    fi

    if [ "$(confirm "Do you want to merge '$current_branch'?")" = "yes" ]; then
        echo -n "Merging '$current_branch'... "

        local result; result=$(gitlab_merge_request_merge "${mr_iid}")

        if [ ! -z "$result" ]; then
            echo -e "OK\n";

            if [ "$(confirm "Do you want to checkout '$base_branch' and pull changes?")" = "yes" ]; then
                echo "git checkout $base_branch && git pull --rebase"

                git checkout "$base_branch" && git pull --rebase
                echo

                if [ "$(confirm "Do you want to delete local branch '$current_branch'")" = "yes" ]; then
                    echo "git branch -d $current_branch"

                    git branch -d "$current_branch"
                fi
            fi
        fi
    fi

    echo
}

function usage
{
    cat << EOF

SYNOPSIS

    mr [OPTIONS]        [ISSUE_CODE] [BASE_BRANCH]
    mr [OPTIONS] open   [ISSUE_CODE] [BASE_BRANCH]
    mr [OPTIONS] update [BASE_BRANCH]
    mr [OPTIONS] merge
    mr [OPTIONS] unwip

OPTIONS

    -v  Verbose output (displays called API URLs)
    -y  Bypass confirmation prompts ("yes")

INSTALLATION

    Add the git-mr directory to your PATH

        PATH="\${PATH}:/path/to/git-mr"

    OR

    Define it as a git alias:

        git config --global alias.mr '!bash /path/to/git-mr/git-mr'

        or edit your ~/.gitconfig directly:

            [alias]
                mr = "!bash /path/to/git-mr/git-mr"

    Ensure jq is installed to be able to update or merge.

CONFIGURATION

    You need to configure the following environment variables:

        export JIRA_USER="user.name@mycompany.com"
        export JIRA_INSTANCE="mycompany.atlassian.net"
        export JIRA_TOKEN="abcdefghijklmnopqrstuvwx"
        export JIRA_CODE_PATTERN="XY-[0-9]+"

        export GITLAB_DOMAIN="myapp.gitlab.com"
        export GITLAB_TOKEN="Zyxwvutsrqponmlkjihg"

    To create a Jira API Token, go to: https://id.atlassian.com/manage-profile/security/api-tokens
    (Account Settings -> Security -> API Token -> Create and manage API tokens)

    To create a Gitlab API Token, go to: https://myapp.gitlab.com/profile/personal_access_tokens<br>
    (Settings -> Access Tokens)

    Optional configuration variables:

        export GITLAB_DEFAULT_LABELS="Review,My Team"       # Default labels for new merge requests
        export GITLAB_DEFAULT_FORCE_REMOVE_SOURCE_BRANCH=1  # Check "Delete source branch" by default

        export GIT_MR_TIMEOUT=5  # Timeout for HTTP API calls

EOF
}


################################################################################
# Run

# Init

git rev-parse > /dev/null 2>&1 || exit_error 1 "Not a git repository"

if [ ! -x "$(command -v jq)" ]; then
    echo_error "Please install jq for full actions support (update, merge, ...)."
fi


# Parse options
args=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -v|-V) GIT_MR_VERBOSE=1 ;;
        -y|-Y) GIT_MR_YES=1     ;;

        *) args+=("${1}") ;;
    esac
    shift
done
set -- "${args[@]}"


# Run
case $1 in

    help|usage) usage ;;

    open)   mr_open   "${@:2}" ;;
    update) mr_update "${@:2}" ;;
    merge)  mr_merge  "${@:2}" ;;

    unwip)  gitlab_unwip ;;

    *) mr_print "$@" ;;

esac


################################################################################
# Error code reference:
#
#   1   Not a git repository
#   2   jq is required for this operation
#
#  10   Gitlab request error
#  11   GITLAB_DOMAIN|GITLAB_TOKEN is not set
#  12   Unable to determine Gitlab project URL
#
#  20   Jira request error
#  21   JIRA_USER|JIRA_TOKEN|JIRA_INSTANCE is not set
#
