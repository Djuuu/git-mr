#!/usr/bin/env bash

################################################################################
# Git functions

git_current_branch() {
    # `git branch --show-current` is available starting from Git 2.22
    # fallback to `git rev-parse --abbrev-ref HEAD` if first command fails
    (git branch --show-current 2>/dev/null) ||
        git rev-parse --abbrev-ref HEAD
}

git_base_branch() {
    local branch=${1:-$(git_current_branch)}

    local default_branch; default_branch=$(git_default_branch)

    [[ -n $branch ]]                   || exit "$ERR_GIT" # Not on any branch
    [[ $branch != "$default_branch" ]] || exit "$ERR_GIT" # On default branch
    git_branch_exists "$branch"        || exit "$ERR_GIT" # Branch does not exist

    # Nearest branch in commit history
    local base_branch
    local refs_logs; refs_logs=$(git log --oneline --decorate "${branch}" \
            --simplify-by-decoration --decorate-refs='refs/heads/*') # select only commits with a local branch

    local ref_count; ref_count="${refs_logs//[!$'\n']/}"; ref_count=$((${#ref_count} + 1))
    if [[ $ref_count -gt 1 ]]; then
        base_branch=$( \
            echo "$refs_logs" |
            sed '
                2!d  # keep only 2nd line (closest decoration before current HEAD)
                s/[a-f0-9]* (\([^),]*\).*/\1/  # keep only first decoration
            ')
    fi

    # First possible merge base
    if ! git_branch_exists "$base_branch"; then
        base_branch=$(git show-branch --merge-base "$branch" "$default_branch" | head -n1)
    fi

    echo_debug "Base branch: $base_branch"

    echo "$base_branch"
}

git_remote() {
    git remote | head -n1
}

git_branch_exists() {
    local branch=$1

    git show-ref -q --heads "$branch"
}

git_default_branch() {
    local remote; remote=$(gitlab_remote || git_remote)
    local default; default=$(git symbolic-ref "refs/remotes/${remote}/HEAD" -- 2>/dev/null)

    if [[ -n $default ]]; then
        local local_tracking
        local_tracking=$(git branch -vv | grep "${default#"refs/remotes/"}")
        local_tracking=${local_tracking:2} # remove first 2 characters ("  " or "* ")
        local_tracking=${local_tracking%% *} # remove all trailing characters after first space (included)
        # -> only short local branch name remains

        # local branch tracking default remote with a different name
        [[ -n $local_tracking ]] && echo "$local_tracking" && return 0

        # short local name of remote default
        echo "${default#"refs/remotes/${remote}/"}"
        return 0
    fi

    git_branch_exists "main"   && echo "main"   && return 0
    git_branch_exists "master" && echo "master" && return 0
}

git_remote_branch_exists() {
    local branch=$1
    local remote=${2:-$(gitlab_remote)}

    [[ -n "$(git ls-remote --heads "$remote" "$branch")" ]]
}

git_check_branches() {
    local source_branch="$1"
    local target_branch="$2"

    [[ -n $source_branch ]] ||
        exit_error "$ERR_GIT" "Not on any branch"

    [[ $source_branch != "$(git_default_branch)" ]] ||
        exit_error "$ERR_GIT" "On default branch"

    git_branch_exists "$source_branch" ||
        exit_error "$ERR_GIT" "Branch '$source_branch' does not exist"

    [[ -n $target_branch ]] ||
        exit_error "$ERR_GIT" "Unable to determine target branch"

    [[ $target_branch == "$GIT_MR_TARGET" ]] && ! git_branch_exists "$target_branch" &&
        exit_error "$ERR_GIT" "Branch '$target_branch' does not exist"

    return 0
}

git_commits() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}

    git log --oneline --reverse --no-decorate "${target_branch}..${source_branch}"
}

git_commits_extended() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}

    local prefix="* ${MD_BOLD}"
    local suffix="${MD_BOLD}${MD_BR}"

    local end="---COMMIT-BODY-END---" # useful to remove trailing blank line

    local format="${prefix}%h %s${suffix}%n%b${end}"

    git log --reverse --no-decorate --format="${format}" "${target_branch}".."${source_branch}" |
        grep -v "^${end}" | # remove trailing blank line
        sed -r "s/${end}$//g" # remove trailing body end for bodies without trailing blank line
}

git_commit_extended() {
    local revision=${1:-HEAD}

    local prefix="* ${MD_BOLD}"
    local suffix="${MD_BOLD}${MD_BR}"

    local end="---COMMIT-BODY-END---" # useful to remove trailing blank line

    local format="${prefix}%h %s${suffix}%n%b${end}"

    git show -s --format="${format}" "${revision}" |
        grep -v "^${end}" | # remove trailing blank line
        sed -r "s/${end}$//g" # remove trailing body end for bodies without trailing blank line
}

git_titlize_branch() {
    local branch=${1:-$(git_current_branch)}

    # Split prefix, issue id & label parts

    local branch_split_pattern="^(.*)($JIRA_CODE_PATTERN)[^a-zA-Z0-9]?(.*)$"

    local prefix;   prefix=$(  echo "$branch" | sed -r "s/$branch_split_pattern/\1/") # ex: 'feature/'
    local issue_id; issue_id=$(echo "$branch" | sed -r "s/$branch_split_pattern/\2/") # ex: 'XY-1234'
    local label;    label=$(   echo "$branch" | sed -r "s/$branch_split_pattern/\3/") # ex: 'my-branch-name'

    # When Jira code pattern is not matched
    if [[ $prefix == "$issue_id" ]]; then
        # Split prefix & label parts
        branch_split_pattern="^([^\/]*\/?)(.*)$"
        prefix=$(echo "$branch" | sed -r "s/$branch_split_pattern/\1/")
        label=$(echo "$branch" | sed -r "s/$branch_split_pattern/\2/")
        issue_id=
    else
        issue_id="$issue_id " # add space
    fi

    # When Jira code pattern and prefix are not matched
    if [[ -z $label ]]; then
        label="$prefix"
        prefix=
    fi

    # Formatting
    local title_ref;   title_ref="${prefix^}${issue_id}"
    local title_label; title_label=${label^}
    title_label=${title_label//-/ }
    title_label=${title_label//_/ }

    echo "${title_ref}${title_label}"
}


################################################################################
# Misc. utilities

# sed wrapper (use gsed if available on Mac)
sed() {
    if type gsed >/dev/null 2>&1; then
        gsed "$@"
    else
        command sed "$@"
    fi
}

# grep wrapper (use ggrep if available on Mac)
grep() {
    if type ggrep >/dev/null 2>&1; then
        ggrep "$@"
    else
        command grep "$@"
    fi
}

exit_error() {
    local code=$1
    local msg="$2"

    echo_error "$msg"
    exit "$code"
}

# https://gist.github.com/cdown/1163649#gistcomment-1639097
urlencode() {
    local oLANG="$LANG"
    local oLC_ALL="$LC_ALL"
    LANG=C
    LC_ALL=C
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "%s" "$c" ;;
            *) printf '%%%02X' "'$c" ;;
        esac
    done
    LANG="$oLANG"
    LC_ALL="$oLC_ALL"
}

has_terminal_colors() {
    command -v tput > /dev/null 2>&1 &&
    [[ -n $TERM ]] &&
    [[ "$(tput -T"$TERM" colors)" -ge 8 ]]
}

has_colors() {
    [[ $GIT_MR_NO_COLORS -ne 1 ]] && has_terminal_colors
}

has_links() {
    [[ $GIT_MR_NO_TERMINAL_LINK -ne 1 ]] && has_terminal_colors
}

# shellcheck disable=SC2034 # Ignore unused color variables
colorize() {
    local input=$1

    if has_colors; then
        local bold='\e[1m'; local nobold='\e[21m'

        local red='\e[31m';    local lightred='\e[91m'
        local green='\e[32m';  local lightgreen='\e[92m'
        local orange='\e[33m'; local lightyellow='\e[93m'
        local blue='\e[34m';   local lightblue='\e[94m'
        local purple='\e[35m'; local lightpurple='\e[95m'
        local cyan='\e[36m';   local lightcyan='\e[96m'
        local gray='\e[090m';  local lightgray='\e[37m'

        local midgray='\e[38;5;247m'

        local reset='\e[0m'

        for style in "${@:2}"; do
            echo -en "${!style}"
        done
        echo -en "$input"
        echo -en "$reset"
    else
        echo -en "$input"
    fi
}

echolor() {
    colorize "$1\n" "${@:2}"
}

# https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda
terminal_link() {
    local href=$1
    local text=$2

    if has_links; then
        printf "\e]8;;%s\e\\%s\e]8;;\e\\" "$href" "$text"
    else
        echo -n "$text"
    fi
}

echolink() {
    terminal_link "$@"; echo
}

echo_error() {
    colorize "$1\n" "orange" >&2
}

echo_debug() {
    [[ $GIT_MR_VERBOSE -eq 1 ]] || return 0

    colorize "$1\n" "gray" >&2
}

echo_spacer() {
    local count=$1
    local char=${2:-" "}

    for ((i=1; i <= count; i++)); do
        echo -n "$char"
    done
}

trim() {
    # shellcheck disable=SC2064 # expand now to restore initial value on exit
    trap "$(shopt -p extglob)" RETURN
    shopt -s extglob

    local str=$1
    local char=$2

    str=${str##*("$2")} # trim leading characters
    str=${str%%*("$2")} # trim trailing characters

    echo "$str"
}

confirm() {
    local question=$1

    if [[ $GIT_MR_YES -eq 1 ]]; then
        echo "$(colorize "${question}" "cyan") -> yes" >&2
        return 0
    fi

    local response
    read -r -p "$(colorize "$question" "lightcyan" "bold") [y/N] " response
    case "$response" in
        [yY][eE][sS]|[yY]) return 0 ;;
        *)                 return 1 ;;
    esac
}

clear_screen() {
    command -v tput > /dev/null 2>&1 &&
    [[ -n $TERM ]] &&
        tput -x clear
}

jq_build() {
    local key=${1}
    local value=${2}
    local initial_data=${3:-"{}"}

    local is_obj; is_obj=$(echo "$value" | grep '^{.*}$')
    local is_num; is_num=$(echo "$value" | grep '^[0-9]*$')

    local current_object

    if [[ -n $is_obj || -n $is_num ]]; then
        current_object="$(jq --null-input --compact-output --argjson value "$value" "{\"${key}\": \$value}")"
    else
        current_object="$(jq --null-input --compact-output --arg     value "$value" "{\"${key}\": \$value}")"
    fi

    jq --null-input --compact-output \
        --argjson initial_data "$initial_data" \
        --argjson current_object "$current_object" \
        '$initial_data + $current_object'
}

# escape regex special characters for literal usage
regex_escape() {
    echo "${1}" | sed -e 's/[]\/$*.^[]/\\&/g'
}

open_in_browser() {
    local url=$1

    [[ -n $url ]] || return "$ERR_MR"

    local open_command open_args
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        if grep -qi microsoft /proc/version; then
            # https://github.com/microsoft/WSL/issues/3832#issuecomment-1173571126
            open_command='rundll32.exe'
            open_args="url.dll,FileProtocolHandler"
        else                                      open_command='xdg-open'; fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then open_command='open';
    elif [[ "$OSTYPE" == "msys"*   ]]; then open_command='explorer';
    fi

    if [[ -n $open_command && -x "$(command -v "$open_command")" ]]; then
        "$open_command" "$open_args" "${url}" > /dev/null 2>&1
        return 0
    fi

    echo_error "Unable to open browser"
    echo_error
    echo "${url}"
    echo
    return "$ERR_MR"
}

git_mr_readonly() {
    [[ $GIT_MR_READONLY -eq 1 ]] || return 1

    [[ -n $1 ]] &&
        echolor "🚫 Read-only 🚫" "gray" >&2

    return 0
}


################################################################################
# Markdown formatting

markdown_title() {
    local label=$1
    local level=${2:-1}

    for ((i=1; i<=level; i++)); do
        echo -n '#'
    done

    echo " ${label}"
}

markdown_link() {
    local label=$1
    local url=$2

    if [[ -z $url ]]; then
        echo "[$label]"
        return 0
    fi

    echo "[$label]($url)"
}

markdown_list() {
    local content=$1

    local prefix="* ${MD_BOLD}"
    local suffix="${MD_BOLD}${MD_BR}"

    echo "${prefix}${content//$'\n'/${suffix}$'\n'${prefix}}${suffix}"
}

markdown_indent_list_items() {
    local content=$1

    local list_prefix_pattern
    list_prefix_pattern="$(regex_escape "* ${MD_BOLD}")"

    # indent extended description (not starting with list prefix)
    local indent="  "
    echo "$content" | sed -E \
        -e "/^${list_prefix_pattern}/! s/^(.*)$/${indent}\1${MD_BR}/gm" \
        -e "s/^${indent}${MD_BR}$/${indent}/gm"
}


################################################################################
# Jira functions

jira_check_env() {
    [[ -n $JIRA_USER ]]     || exit_error "$ERR_MR_ENV" "JIRA_USER is not set"
    [[ -n $JIRA_TOKEN ]]    || exit_error "$ERR_MR_ENV" "JIRA_TOKEN is not set"
    [[ -n $JIRA_INSTANCE ]] || exit_error "$ERR_MR_ENV" "JIRA_INSTANCE is not set"
}

jira_request() {
    jira_check_env

    local request_url=$1
    local request_verb=${2:-"GET"}
    local request_data=${3}

    local jira_base_url="https://${JIRA_INSTANCE}/rest/api/3"

    echo_debug "Jira - ${request_verb} ${request_url} ${request_data}"

    [[ $request_verb != "GET" ]] && git_mr_readonly && return 0

    curl -Ss \
        -X "${request_verb}" \
        -u "${JIRA_USER}:${JIRA_TOKEN}" \
        -H "Content-Type: application/json" \
        --data "${request_data}" \
        --max-time "${GIT_MR_TIMEOUT}" \
        "${jira_base_url}/${request_url}" || exit_error "$ERR_JIRA_API" "Jira request error"
}

jira_ticket_data() {
    jira_check_env

    local issue_code=$1;  [[ -n $issue_code ]] || exit_error "$ERR_MR" "issue_code required"

    jira_request "issue/${issue_code}?fields=summary" || exit $?
}

jira_show_transitions() {
    local issue_code=${1:-${GIT_MR_CODE:-$(guess_issue_code "$(git_current_branch)")}}

    echo "Available Jira transitions:"
    jira_request "issue/${issue_code}/transitions" |
        jq -r '.transitions[] | [
            "", .id,
            "\"" + .name + "\"" + (" " * (23 - (.name | length))),
            "-> " + (.to | .name + (" " * (23 - (.name | length)))),
            "[" + .to.statusCategory.name + "]"
        ] | @tsv' |
        tr -d '\r'
}

jira_transition() {
    jira_check_env

    local issue_code=$1;     [[ -n $issue_code    ]] || exit_error "$ERR_MR" "issue_code required"
    local transition_id=$2;  [[ -n $transition_id ]] || exit_error "$ERR_MR" "transition_id required"

    local transition;   transition=$(jq_build "id" "$transition_id")        || exit "$ERR_MR"
    local request_data; request_data=$(jq_build "transition" "$transition") || exit "$ERR_MR"

    jira_request "issue/${issue_code}/transitions" "POST" "$request_data" || exit $?
}


################################################################################
# Gitlab functions

gitlab_check_env() {
    [[ -n $GITLAB_DOMAIN ]] || exit_error "$ERR_MR_ENV" "GITLAB_DOMAIN is not set"
    [[ -n $GITLAB_TOKEN ]]  || exit_error "$ERR_MR_ENV" "GITLAB_TOKEN is not set"
}

gitlab_remote() {
    local remote remote_url

    for remote in $(git remote); do
        remote_url=$(git remote get-url --push "$remote" | grep "${GITLAB_DOMAIN}" || true)
        [[ -n "$remote_url" ]] && echo "$remote" && return 0
    done

    return "$ERR_GIT_REPO"
}

gitlab_project_url() {
    local remote
    local remote_url
    local project_url

    remote=$(gitlab_remote)
    [[ -n $remote ]] &&
        remote_url=$(git remote get-url --push "$remote" | grep "${GITLAB_DOMAIN}")

    if [[ "$remote_url" == git* ]]; then
        project_url=$remote_url
        project_url=${project_url#"git@${GITLAB_DOMAIN}:"}
        project_url=${project_url%".git"}
    elif [[ "$remote_url" == https* ]]; then
        project_url=$remote_url
        project_url=${project_url#"https://${GITLAB_DOMAIN}/"}
        project_url=${project_url%".git"}
    fi

    if [[ -z $project_url ]]; then
        remote=$(git remote | head -n 1)
        remote_url=$(git remote get-url --push "$remote")

        local suggested_domain
        suggested_domain=$(git remote get-url --push "$remote" | sed 's/.*@\(.*\):.*/\1/')

        exit_error "$ERR_GIT_REPO" "$(cat <<- EOF
			Unable to determine Gitlab project URL, check GITLAB_DOMAIN configuration
			  ${remote}:     ${remote_url}
			  current:    GITLAB_DOMAIN="${GITLAB_DOMAIN}"
			  Suggestion: GITLAB_DOMAIN="${suggested_domain}"
		EOF
        )"
    fi

    echo "$project_url"
}

gitlab_current_project_request() {
    gitlab_check_env

    local request_url=$1
    local request_verb=${2:-"GET"}
    local request_data=${3}

    local project_url; project_url=$(gitlab_project_url) || exit $?

    gitlab_project_request "$project_url" "$request_url" "$request_verb" "$request_data"
}

gitlab_project_request() {
    local project_url=$1
    local request_url=$2
    local request_verb=${3:-"GET"}
    local request_data=${4}

    gitlab_request "projects/$(urlencode "$project_url")/${request_url}" "$request_verb" "$request_data"
}

gitlab_request() {
    gitlab_check_env

    local request_url=$1
    local request_verb=${2:-"GET"}
    local request_data=${3}

    local gitlab_base_url="https://${GITLAB_DOMAIN}/api/v4"

    echo_debug "GitLab - ${request_verb} ${gitlab_base_url}/${request_url} ${request_data}"

    [[ $request_verb != "GET" ]] && git_mr_readonly && echo '{}' && return 0

    local result
    result=$(curl -Ss \
        -X "${request_verb}" \
        -H "Private-Token: ${GITLAB_TOKEN}" \
        -H "Content-Type: application/json" \
        --data "${request_data}" \
        --max-time "${GIT_MR_TIMEOUT}" \
        "${gitlab_base_url}/${request_url}") || exit_error "$ERR_GITLAB_API" "Gitlab request error"

    if [[ $request_verb != "GET" ]]; then
        [[ -z "$(gitlab_check_error "$result")" ]] || return "$ERR_GITLAB"
    fi

    echo "$result"
}

gitlab_check_error() {
    local result=$1

    local hasErrorMessage
    hasErrorMessage=$(echo "$result" | jq 'if type=="object" then (has("error") or has("message")) else false end')

    if [[ $hasErrorMessage == 'true' ]]; then
        echo_error "\nGitlab error:\n  ${result}"

        echo "ko"
    fi
}

gitlab_new_merge_request_url() {
    gitlab_check_env

    local project_url; project_url=$(gitlab_project_url) || exit $?

    local source_branch=${1:-$(git_current_branch)}
    if ! git_remote_branch_exists "$source_branch"; then
        echo_error "Branch '$source_branch' does not exist on remote"
        return "$ERR_GITLAB"
    fi

    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}
    if ! git_remote_branch_exists "$target_branch"; then
        echo_error "Target branch '$target_branch' does not exist on remote"
        return "$ERR_GITLAB"
    fi

    local gitlab_mr_url="https://${GITLAB_DOMAIN}/${project_url}/-/merge_requests/new"

    gitlab_mr_url="${gitlab_mr_url}?$(urlencode "merge_request[source_branch]")=${source_branch}"
    gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[target_branch]")=${target_branch}"

    # default labels
    for label_id in $(gitlab_default_label_ids); do
        gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[label_ids][]")=${label_id}"
    done

    # other options
    if [[ "${GITLAB_REMOVE_SOURCE_BRANCH_ON_MERGE}" -eq 1 ]]; then
        gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[force_remove_source_branch]")=1"
    fi

    # title
    local title
    title=$(git_titlize_branch "$source_branch")
    title=$(gitlab_title_to_draft "$title")
    title=$(urlencode "$title")
    gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[title]")=${title}"

    echo "$gitlab_mr_url"
}

gitlab_merge_request_summary() {
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    local result
    result=$(gitlab_current_project_request "merge_requests?state=opened&view=simple&source_branch=${source_branch}") || exit $?

    [[ -n $result && $result != "[]" ]] || return "$ERR_GITLAB"

    echo "$result" | jq '.[0]'
}

gitlab_merge_requests_search() {
    gitlab_check_env

    local search_term=$1;  [[ -n $search_term ]] || exit_error "$ERR_MR" "search_term required"

    local result
    result=$(gitlab_request "merge_requests?scope=all&state=all&view=simple&search=$(urlencode "$search_term")&in=title&per_page=50&order_by=created_at&sort=asc") || exit $?
    [[ -n $result && $result != "[]" ]] || return "$ERR_GITLAB"

    result=$(echo "$result" | jq -c 'map(select(.state != "closed") | {iid: .iid, title: .title, web_url: .web_url, state: .state, project_id: .project_id}) | sort_by(.state)')
    [[ -n $result && $result != "[]" ]] || return "$ERR_GITLAB"

    echo "$result"
}

gitlab_projects() {
    local result

    result=$(gitlab_request "projects?simple=true&archived=false&order_by=last_activity_at&per_page=${GIT_MR_LAST_PROJECTS_LIMIT:-40}") || exit $?
    [[ -n $result && $result != "[]" ]] || return "$ERR_GITLAB"

    result=$(echo "$result" | jq 'map({id: .id, name: .name, path_with_namespace: .path_with_namespace})')
    [[ -n $result && $result != "[]" ]] || return "$ERR_GITLAB"

    echo "$result"
}

gitlab_merge_request() {
    gitlab_check_env

    local mr_iid=$1;        [[ -n $mr_iid ]] || exit_error "$ERR_MR" "No mr_iid provided"
    local project_url=$2;   [[ -n $project_url ]] || project_url=$(gitlab_project_url) || exit $?

    gitlab_project_request "$project_url" "merge_requests/$mr_iid"
}

gitlab_extract_iid() {
    local mr_summary=$1
    echo "$mr_summary" | jq -r '.iid'
}

gitlab_extract_url() {
    local mr_summary=$1
    echo "$mr_summary" | jq -r '.web_url'
}

gitlab_extract_title() {
    local mr_summary=$1
    echo "$mr_summary" | jq -r '.title'
}

gitlab_extract_description() {
    local mr_summary=$1
    echo "$mr_summary" | jq -r '.description'
}

gitlab_extract_merge_status() {
    local mr_detail=$1

    if [[ "$(echo "$mr_detail" | jq -r '.state')" == "merged" ]]; then
        echo "merged"
        return 0
    fi

    echo "$mr_detail" | jq -r '.merge_status'
}

gitlab_extract_pipeline_status() {
    local mr_detail=$1

    echo "$mr_detail" | jq -r '.head_pipeline.status'
}

gitlab_extract_pipeline_url() {
    local mr_detail=$1

    echo "$mr_detail" | jq -r '.head_pipeline.web_url'
}

gitlab_extract_target_branch() {
    local mr_detail=$1
    echo "$mr_detail" | jq -r '.target_branch'
}

gitlab_extract_labels() {
    local mr_detail=$1
    echo "$mr_detail" | jq -r '.labels | join(",")'
}

gitlab_extract_project_url_part() {
    local url=$1

    url=${url#"https://${GITLAB_DOMAIN}/"} # remove prefix
    url=${url%"/-/merge_requests/"*} # remove suffix

    echo "$url"
}

gitlab_merge_request_threads() {
    gitlab_check_env

    local mr_url=$1

    local mr_iid="${mr_url##*/}"
    local project_url; project_url="$(gitlab_extract_project_url_part "$mr_url")"

    [[ -n $mr_url ]]      || exit_error "$ERR_MR" "No mr_url provided"
    [[ -n $mr_iid ]]      || exit_error "$ERR_MR" "Unable to determine mr_iid from mr_url"
    [[ -n $project_url ]] || exit_error "$ERR_MR" "Unable to determine project_url from mr_url"

    local thread_summaries
    local per_page=100
    local page=1
    local notes_page_count=${per_page}

    while [[ $notes_page_count -eq "$per_page" ]]; do

        # fetch page
        local notes_page
        notes_page=$(gitlab_project_request "$project_url" "merge_requests/${mr_iid}/discussions?per_page=${per_page}&page=${page}")

        if [[ $notes_page != "[]" ]]; then

            local thread_summaries_page
            thread_summaries_page=$(echo "$notes_page" | jq -r '
                .[] | select(any(.notes[]; .resolvable == true)) | {
                    id: .id,
                    resolvables: .notes | map(select(.resolvable == true) | {id: .id, resolved: .resolved})
                } |
                .id + "\t" +
                "unresolved:" + (any(.resolvables[]; .resolved == false) | tostring) + "\t" +
                "note_id:" + (.resolvables | map(select(.resolved == false)) | first | .id | tostring)
            ' | tr -d '\r')

            # append page
            if [[ -z $thread_summaries ]]; then
                thread_summaries="$thread_summaries_page"
            else
                thread_summaries=$(echo -e "${thread_summaries}\n${thread_summaries_page}")
            fi

            # increment
            notes_page_count=$(echo "$notes_page" | jq -r 'length')
            page=$((page + 1))
        else
            notes_page_count=0
        fi
    done

    echo "$thread_summaries"
}

gitlab_default_label_ids() {
    gitlab_check_env

    local gitlab_labels; gitlab_labels=$(gitlab_current_project_request "labels")

    echo "$GITLAB_DEFAULT_LABELS" | jq -R -r \
        --argjson gitlab_labels "$gitlab_labels" \
        'split(",") | .[] | . as $name | $gitlab_labels | map(select(.name == $name) | .id) | .[]' |
        tr -d '\r'
}

gitlab_merge_request_update() {
    gitlab_check_env

    local mr_iid=$1;   [[ -n $mr_iid ]]  || exit_error "$ERR_MR" "No mr_iid provided"
    local mr_data=$2;  [[ -n $mr_data ]] || exit_error "$ERR_MR" "No data provided"

    local project_url=$3;   [[ -n $project_url ]] || project_url=$(gitlab_project_url) || exit $?

    gitlab_project_request "$project_url" "merge_requests/${mr_iid}" "PUT" "${mr_data}"
}

gitlab_merge_request_merge() {
    gitlab_check_env

    local mr_iid=$1;  [[ -n $mr_iid ]] || exit_error "$ERR_MR" "No mr_iid provided"

    gitlab_current_project_request "merge_requests/${mr_iid}/merge?should_remove_source_branch=${GITLAB_REMOVE_SOURCE_BRANCH_ON_MERGE}" "PUT"
}

gitlab_title_is_draft() {
    local title=$1
    for prefix in "${GITLAB_DRAFT_PREFIXES[@]}"; do
        [[ $title =~ ^${prefix}: ]] && return 0
    done
    return 1
}

gitlab_title_to_draft() {
    local title=$1
    echo "${GITLAB_DRAFT_PREFIX}: $title"
}

gitlab_title_undraft() {
    local title=$1
    for prefix in "${GITLAB_DRAFT_PREFIXES[@]}"; do
        title=${title#"${prefix}: "}
    done
    echo "$title"
}

gitlab_undraft() {
    git_mr_readonly show
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    # Search existing merge request
    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"
        mr_print "$source_branch"
        return "$ERR_GITLAB"
    fi

    local mr_iid mr_url mr_title
    eval "$(echo "$mr_summary" | jq -r '
        "mr_iid="   + (.iid     | @sh) + ";\n" +
        "mr_url="   + (.web_url | @sh) + ";\n" +
        "mr_title=" + (.title   | @sh) + ";\n"
    ')"

    # Print merge request status summary
    echo
    mr_status_block "$mr_summary" "" "" "$mr_iid" "$mr_url" "$mr_title"
    echo "--------------------------------------------------------------------------------"
    echo

    if ! gitlab_title_is_draft "$mr_title"; then
        echo_error "Merge request is not a draft"
        echo_error
        return 0
    fi

    local undraft_title; undraft_title=$(gitlab_title_undraft "$mr_title")

    if confirm "Do you want to resolve draft status?"; then
        echo -n "Resolving draft status... "

        local mr_data; mr_data=$(jq_build "title" "$undraft_title") || exit "$ERR_MR"

        local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_data")
        [[ -n $result ]] && echo -e "OK\n"
    fi
}

# Async functions

gitlab_load_mr() {
    exec {git_mr_fd_mr}< <(gitlab_merge_request "$@")
}

gitlab_load_threads() {
    exec {git_mr_fd_th}< <(gitlab_merge_request_threads "$@")
}

gitlab_read_mr() {
    local var_name=$1
    IFS= read -r -d '' -u "$git_mr_fd_mr" "$var_name"
    exec {git_mr_fd_mr}<&-
}

gitlab_read_threads() {
    local var_name=$1
    IFS= read -r -d '' -u "$git_mr_fd_th" "$var_name"
    exec {git_mr_fd_th}<&-
}

################################################################################
# Merge request utility functions

guess_issue_code() {
    [[ -z $git_mr_unguessable_issue_code ]] || return
    [[ -n $JIRA_CODE_PATTERN ]] || { echo_error "JIRA_CODE_PATTERN not set - unable to guess issue code"; return "$ERR_MR_ENV"; }

    local branch=${1:-$(git_current_branch)}

    local issue_code; issue_code=$(echo "${branch}" |
        grep -Eo "$JIRA_CODE_PATTERN" |
        tail -n1)

    if [[ -z $issue_code ]]; then
        echo_error "Unable to guess issue code"
        return 1
    fi

    echo_debug "Issue code: $issue_code"

    echo "$issue_code"
}

mr_title() {
    local source_branch=${1:-$(git_current_branch)}
    local issue_code=${2:-${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}}

    if [[ -z $issue_code ]]; then
        git_titlize_branch "$source_branch"
        return 0
    fi

    local issue_content; issue_content=$(jira_ticket_data "$issue_code")

    local issue_key issue_title
    eval "$(echo "$issue_content" | jq -r '
        "issue_key="   + (.key            // empty | @sh) + ";\n" +
        "issue_title=" + (.fields.summary // empty | @sh) + ";\n"
    ')"

    [[ -z $issue_key ]] &&
        issue_key=${issue_code^^}

    if [[ -z $issue_title ]]; then
        echo_error "Unable to get issue title from Jira"
        echo_error "  issue_code: $issue_code"
        [[ -n $issue_content ]] &&
            echo_error "  $issue_content"

        echo "$issue_key"
        return 0
    fi

    local issue_url="https://${JIRA_INSTANCE}/browse/${issue_key}"

    markdown_link "${issue_key} ${issue_title}" "$issue_url"
}

mr_commit_list() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}

    if [[ $GIT_MR_EXTENDED -eq 1 ]]; then
        markdown_indent_list_items "$(git_commits_extended "$source_branch" "$target_branch")"
    else
        markdown_list "$(git_commits "$source_branch" "$target_branch")"
    fi
}

mr_description() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}
    local issue_code=${3:-${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}}

    local title; title=$(mr_title "$source_branch" "$issue_code")

    if [[ "${GIT_MR_NO_COMMITS}" == "1" ]]; then
        mr_print_description "$title"
    else 
        mr_print_description "$title" "$(mr_commit_list "$source_branch" "$target_branch")"
    fi
    
}

mr_print_description() {
    local title=$1
    if [[ -n $2 ]]; then
        local commit_list=$2
        cat <<EOF
$(markdown_title "$title")


## Commits

${commit_list}

EOF
    else
        cat <<EOF
$(markdown_title "$title")

EOF
    fi
}

mr_status_block() {
    local mr_summary=$1
    local merge_request=$2
    local mr_threads=$3

    local mr_iid=$4
    local mr_url=$5
    local mr_title=$6

    local parse=()
    [[ -z $merge_request && -z $mr_iid ]] && parse+=('"mr_iid=" + (.iid | @sh) + ";\n" +')
    [[ -z $mr_url ]]                      && parse+=('"mr_url=" + (.web_url | @sh) + ";\n" +')
    [[ -z $mr_title ]]                    && parse+=('"mr_title=" + (.title | @sh) + ";\n" +')
    [[ ${#parse[@]} -gt 0 ]] && {
        parse+=('""')
        eval "$(echo "$mr_summary" | jq -r "${parse[*]}")"
    }

    # Load merge request & threads in parallel
    [[ -n $merge_request ]] || gitlab_load_mr "$mr_iid"
    [[ -n $mr_threads  ]]   || gitlab_load_threads "$mr_url"

    mr_print_title "$mr_title" "$mr_url"

    # Read MR & threads
    [[ -n $merge_request ]] || gitlab_read_mr merge_request
    [[ -n $mr_threads  ]]   || gitlab_read_threads mr_threads

    mr_print_status "$merge_request" "$mr_threads"
}

mr_print_title() {
    local mr_title=$1
    local mr_url=$2

    echo "--------------------------------------------------------------------------------"
    echo " $(terminal_link "$mr_url" "$(gitlab_title_undraft "$mr_title")")"
    has_links || echolor " ⇒ $mr_url" "midgray"
    echo "--------------------------------------------------------------------------------"
}

mr_print_status() {
    local merge_request=$1
    local threads=$2

    [[ -n $merge_request ]] || exit_error "$ERR_MR" "merge_request not provided"

    local mr_url \
        title \
        labels \
        labels_count \
        upvotes \
        downvotes \
        merge_status \
        pipeline_status \
        pipeline_url \
        current_target

    eval "$(echo "$merge_request" | jq -r '
        "mr_url="          + (.web_url               | @sh) + ";\n" +
        "title="           + (.title                 | @sh) + ";\n" +
        "labels="          + (.labels | join(",")    | @sh) + ";\n" +
        "labels_count="    + (.labels | length       | @sh) + ";\n" +
        "upvotes="         + (.upvotes               | @sh) + ";\n" +
        "downvotes="       + (.downvotes             | @sh) + ";\n" +
        "merge_status="    + (if .state == "merged"
                              then "merged"
                              else .merge_status end | @sh) + ";\n" +
        "pipeline_status=" + (.head_pipeline.status  | @sh) + ";\n" +
        "pipeline_url="    + (.head_pipeline.web_url | @sh) + ";\n" +
        "current_target="  + (.target_branch         | @sh) + ";\n"
    ')"

    # Labels
    local labels_display; labels_display=$(mr_format_labels "$labels")
    local labels_str_len=$((${#labels} + $((labels_count * 2)) + 4)) # 2 spaces + 2 for larger icon

    # Votes
    if [[ $upvotes -ge ${GIT_MR_REQUIRED_UPVOTES} ]]; then upvotes=$(colorize "$upvotes" "bold" "lightgreen")
    elif [[ $upvotes -gt 0 ]]; then                        upvotes=$(colorize "$upvotes" "bold" "lightyellow")
    else                                                   upvotes=$(colorize "$upvotes" "bold"); fi

    if [[ $downvotes -gt 0 ]];
        then downvotes=$(colorize "$downvotes" "bold" "lightred")
        else downvotes=$(colorize "$downvotes" "bold"); fi

    # Threads
    local thread_count;   thread_count="$(echo "$threads" | grep -c 'unresolved:' || true)"
    local resolved_count; resolved_count="$(echo "$threads" | grep -c 'unresolved:false' || true)"

    local thread_count_display
        thread_count_display=$(colorize "$thread_count" "bold")

    local resolved_count_display; if [[ $resolved_count -lt "$thread_count" ]];
        then resolved_count_display=$(colorize "$resolved_count" "bold" "lightred")
        else resolved_count_display=$(colorize "$resolved_count" "bold" "lightgreen"); fi

    local threads_display="${resolved_count_display}/${thread_count_display}"

    if [[ $resolved_count -lt "$thread_count" ]]; then
        local first_unresolved_thread; first_unresolved_thread=$(echo "$threads" | grep -m 1 'unresolved:true')
        local first_unresolved_note_id; first_unresolved_note_id="${first_unresolved_thread##*:}"

        local note_url="${mr_url}#note_${first_unresolved_note_id}"
        threads_display=$(terminal_link "$note_url" "$threads_display")
    fi

    # Merge status
    local merge_status_icon; if [[ $merge_status == "merged" || $merge_status == "can_be_merged" ]];
        then merge_status_icon="$(colorize "\U00002714" "lightgreen" "bold")"; # heavy check mark
        else merge_status_icon="$(colorize "\U0000274C" "lightred" "bold")"; fi # cross mark

    # Pipeline status
    local pipeline_icon
    case "$pipeline_status" in
        created|waiting_for_resource|preparing|pending|running)
                          pipeline_icon="$(colorize "⏱" "lightgray")" ;;
        success)          pipeline_icon="$(colorize "✔" "lightgreen" "bold")" ;;
        failed)           pipeline_icon="$(colorize "❌" "lightred" "bold")" ;;
        canceled|skipped) pipeline_icon="$(colorize "➖" "lightgray")" ;;
        manual)           pipeline_icon="$(colorize "🔧" "lightgray")" ;;
        scheduled)        pipeline_icon="$(colorize "⏰" "lightgray")" ;;
        null)             pipeline_icon= ;;
        *)                pipeline_icon="$(colorize "?" "lightgray")" ;;
    esac
    local ci_str=
    [[ -n $pipeline_icon ]] &&
        ci_str="CI: $pipeline_icon"

    # Merge target
    local target_display
    target_display="${target_display}$(colorize "(\U000021A3 " "gray")"
    target_display="${target_display}$(colorize "$current_target" "lightpurple")"
    target_display="${target_display}$(colorize ")" "gray")"

    local target_str_len=$((${#current_target} + 4))

    # Draft status
    local draft_str=
    local draft_str_len=0
    if gitlab_title_is_draft "$title"; then
        draft_str="🚧 Draft"
        draft_str_len=12 # 7 chars + 4 spaces + 1 for larger icon
    fi

    # Spacers for CI & target branch indicators
    # Spacers for draft & target branch indicators
    local display_width=76 # not counting 3 leading spaces
    local spacer_chars=$((display_width - labels_str_len - target_str_len - draft_str_len))
    local spacer_chars_l=0
    local spacer_chars_r=0

    if [[ $spacer_chars -gt 0 ]]; then
        spacer_chars_l=$((43 - labels_str_len)) # 42: roughly at the same level as CI indicator
        spacer_chars_r=$((spacer_chars - spacer_chars_l))
        if [[ $spacer_chars_r -lt 0 ]]; then
            spacer_chars_l=$((spacer_chars_l + spacer_chars_r))
            spacer_chars_r=0
        fi
    fi

    # Display
    echo

    # 1st row ------------------------------------------------------------------
    # Labels
    echo -en "   \U0001F3F7  ${labels_display}"
    echo_spacer "$spacer_chars_l"
    # Draft status
    if [[ -n $draft_str ]]; then
        echo -en "  $(colorize "$draft_str" "orange")  "
    else
        echo_spacer $((2 - spacer_chars_l - spacer_chars_r))
    fi
    echo_spacer "$spacer_chars_r"
    # Target
    echo "$target_display"

    echo

    # 2nd row ------------------------------------------------------------------
    # Votes
    echo -en "   \U0001F44D  ${upvotes}"
    echo -en "   \U0001F44E  ${downvotes}"
    # Threads
    if [[ $thread_count -gt 0 ]]; then
        echo -n "     Resolved threads: ${threads_display}"
    else
        echo -n "                          "
    fi
    # Pipeline
    if [[ -n $ci_str ]]; then
        echo -en "      $(terminal_link "$pipeline_url" "$ci_str")  "
    else
        echo -n "             "
    fi
    # Merge status
    if [[ $merge_status != "merged" ]]; then
        echo -en "     Can be merged: ${merge_status_icon}"
    else
        echo -en "            $(colorize "Merged" "lightgreen")"
    fi
    echo -e "\n"
}


################################################################################
# Merge request description functions

mr_description_first_commit_line() {
    local mr_description=$1

    local first_commit_line
    first_commit_line=$(echo "$mr_description" | grep -Pn '^[^0-9a-fA-F]*[0-9a-fA-F]{7,}\s' -m 1 | cut -d: -f1)

    echo "$first_commit_line"
}

mr_description_last_commit_line() {
    local mr_description=$1

    local last_commit_line
    last_commit_line=$(echo "$mr_description" | grep -Pn '^[^0-9a-fA-F]*[0-9a-fA-F]{7,}\s' | tail -n1 | cut -d: -f1)

    local description_after_last_commit
    description_after_last_commit=$(echo "$mr_description" | tail -n "+$((last_commit_line + 1))")

    local next_description_line
    next_description_line=$(echo "$description_after_last_commit" | grep -vn '^  \|^$' -m 1 | cut -d: -f1)

    local last_commit_extended_description
    if [[ -n $next_description_line ]]; then
        last_commit_extended_description=$(echo "$description_after_last_commit" | head -n $(( next_description_line - 1)))
    else
        last_commit_extended_description="$description_after_last_commit"
    fi

    local last_extended_description_line
    last_extended_description_line=$(echo "$last_commit_extended_description" | grep -vn '^$' | tail -n1 | cut -d: -f1)

    echo $((last_commit_line + last_extended_description_line))
}

mr_description_insert_new_commits() {
    local mr_description=$1
    local new_commits=$2
    local last_commit_line=$3
    local for_terminal=$4

    [[ -n $last_commit_line ]] || last_commit_line=$(mr_description_last_commit_line "$mr_description")

    local description_length; description_length=$(echo "$mr_description" | wc -l)

    # Iterate over description lines
    local i=1 mr_description_line trailing_br
    while IFS=$'\n' read -r mr_description_line; do

        # Add trailing markdown newline (that would have been trimmes by Gitlab) to list item on last line.
        # (As other commit lines, to prepare for an extended description going on the next line.)
        [[ $i -eq $description_length && $i -eq $last_commit_line ]] &&
            grep -q '^* ' <<< "$mr_description_line" &&
            trailing_br="$MD_BR"

        echo "${mr_description_line}${trailing_br}"

        # Insert new commits
        if [[ $i -eq $last_commit_line ]]; then
            mr_description_print_new_commits "$new_commits" "$for_terminal"
        fi
        ((i += 1))
    done < <(echo "$mr_description")
}

mr_description_print_new_commits() {
    local new_commits=$1
    local for_terminal=$2

    if [[ $GIT_MR_UPDATE_NEW_SECTION -eq 1 ]]; then
        echo
        if [[ -n $for_terminal ]]; then
            echolor "## ${GIT_MR_UPDATE_NEW_SECTION_NAME:-"Update"}" "bold"; else
            echo "## ${GIT_MR_UPDATE_NEW_SECTION_NAME:-"Update"}";fi
        echo
    fi

    if [[ $GIT_MR_EXTENDED -eq 1 ]]; then
        markdown_indent_list_items "$new_commits"; else
        markdown_list              "$new_commits"; fi
}


################################################################################
# Merge request labels utility functions

replace_labels() {
    local labels=$1
    local to_remove=$2
    local to_add=$3

    # split
    labels=${labels//,/$'\n'}
    to_remove=${to_remove//,/$'\n'}
    to_add=${to_add//,/$'\n'}

    # remove
    labels=$(echo "$labels" | grep -vx "$to_remove"$'\n'"$to_add")

    # add
    [[ -n $to_add ]] && labels="${labels},${to_add}"

    # implode
    labels=${labels//$'\n'/,}

    # trim commas
    labels=${labels%,}
    labels=${labels#,}

    echo "$labels"
}

labels_differ() {
    local old_labels=$1
    local new_labels=$2

    [[ $old_labels == "$new_labels" ]] && return 1

    # split to lines,  sort and de-duplicate,              remove potential empty line,    join back to comma-separated string
    old_labels=$(echo "${old_labels//,/$'\n'}" | sort -u); old_labels=${old_labels#$'\n'}; old_labels=${old_labels//$'\n'/,}
    new_labels=$(echo "${new_labels//,/$'\n'}" | sort -u); new_labels=${new_labels#$'\n'}; new_labels=${new_labels//$'\n'/,}

    [[ $old_labels != "$new_labels" ]]
}

is_status_label() {
    local label=$1
    local status_labels=",${2-"${GITLAB_IP_LABELS},${GITLAB_OK_LABELS},${GITLAB_CR_LABELS},${GITLAB_QA_LABELS}"},"

    echo "$status_labels" | grep -q ",$label,"
}

is_status_ip_label() {
    is_status_label "$1" "$GITLAB_IP_LABELS"
}

is_status_cr_label() {
    is_status_label "$1" "$GITLAB_CR_LABELS"
}

is_status_qa_label() {
    is_status_label "$1" "$GITLAB_QA_LABELS"
}

is_status_ok_label() {
    is_status_label "$1" "$GITLAB_OK_LABELS"
}

mr_format_labels() {
    local labels=$1

    local labels_array; IFS=',' read -ra labels_array <<<"$labels"

    local status_labels=()
    local other_labels=()

    for label in "${labels_array[@]}"; do
        if is_status_ip_label "$label"; then
            # shellcheck disable=SC2086 # Allow splitting of terminal color
            status_labels+=("$(colorize "[$label]" ${GIT_MR_STATUS_IP_LABEL_COLOR:-orange})")
        elif is_status_cr_label "$label"; then
            # shellcheck disable=SC2086 # Allow splitting of terminal color
            status_labels+=("$(colorize "[$label]" ${GIT_MR_STATUS_CR_LABEL_COLOR:-lightblue bold})")
        elif is_status_qa_label "$label"; then
            # shellcheck disable=SC2086 # Allow splitting of terminal color
            status_labels+=("$(colorize "[$label]" ${GIT_MR_STATUS_QA_LABEL_COLOR:-lightpurple bold})")
        elif is_status_ok_label "$label"; then
            # shellcheck disable=SC2086 # Allow splitting of terminal color
            status_labels+=("$(colorize "[$label]" ${GIT_MR_STATUS_OK_LABEL_COLOR:-lightgreen})")
        else
            other_labels+=("[$label]")
        fi
    done

    local status_labels_str; status_labels_str="$(printf "%s " "${status_labels[@]}")"
    local other_labels_str;  other_labels_str="$(printf "%s " "${other_labels[@]}")"

    # shellcheck disable=SC2086 # trim whitespace
    echo ${status_labels_str}${other_labels_str}
}


################################################################################
# Merge request transition utility functions

mr_update_labels() {
    local mr_iid=$1
    local labels=$2
    local to_remove=$3
    local to_add=$4

    if [[ -z $to_remove && -z $to_add ]]; then
        echo_error "No label to add or remove"
        return 0
    fi

    local new_labels; new_labels=$(replace_labels "$labels" "$to_remove" "$to_add")
    if labels_differ "$labels" "$new_labels" &&
       confirm "Do you want to update the merge request labels to \"$new_labels\"?"; then
        echo -n "Updating merge request labels... "

        local mr_data; mr_data=$(jq_build "labels" "$new_labels") || exit "$ERR_MR"
        local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_data")

        [[ -n $result ]] && echo -e "OK\n"
    fi
}

mr_gitlab_draft() {
    local mr_iid=$1
    local mr_summary=$2

    local mr_title; mr_title=$(gitlab_extract_title "$mr_summary")

    ! gitlab_title_is_draft "$mr_title" || return 0

    confirm "Do you want to set draft status?" || return 0

    echo -n "Setting draft status... "

    local draft_title; draft_title=$(gitlab_title_to_draft "$mr_title")
    local mr_data; mr_data=$(jq_build "title" "$draft_title") || exit "$ERR_MR"

    local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_data")
    [[ -n $result ]] && echo -e "OK\n"
}

mr_gitlab_undraft() {
    local mr_iid=$1
    local mr_summary=$2

    local mr_title; mr_title=$(gitlab_extract_title "$mr_summary")

    gitlab_title_is_draft "$mr_title" || return 0

    confirm "Do you want to resolve draft status?" || return 0

    echo -n "Resolving draft status... "

    local undraft_title; undraft_title=$(gitlab_title_undraft "$mr_title")
    local mr_data; mr_data=$(jq_build "title" "$undraft_title") || exit "$ERR_MR"

    local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_data")
    [[ -n $result ]] && echo -e "OK\n"
}

mr_jira_transition() {
    local issue_code=$1
    local jira_target_status=$2
    local jira_transition_id_var=$3

    local jira_transition_id=${!jira_transition_id_var}

    [[ -n $issue_code ]] || return 0

    confirm "Do you want to update the Jira ticket status to \"${jira_target_status}\"?" || return 0

    if [[ -z $jira_transition_id ]]; then
        echo_error "Set ${jira_transition_id_var} to be able to update Jira status."
        jira_show_transitions "$issue_code"
        return 0
    fi

    echo -n "Updating Jira ticket status... "
    jira_transition "$issue_code" "$jira_transition_id" && echo -e "OK\n"
}


################################################################################
# Merge request menu utility functions

mr_menu_merge_requests() {
    local issue_code=${1:-${GIT_MR_CODE:-$(guess_issue_code)}}

    local mr_summaries; mr_summaries=$(gitlab_merge_requests_search "$issue_code") || exit $?
    [[ -n $mr_summaries ]] || return "$ERR_GITLAB"

    # Enrich merge request summaries with project names
    echo "$mr_summaries" | jq -c \
        --argjson projects "$(gitlab_projects | jq 'map({(.id|tostring): .name}) | add')" \
        '.[] | . + { project_name: $projects[(.project_id|tostring)] }'
}

mr_menu_contents() {
    local menu_items=$1
    local current_mr_url=$2

    echo "$GIT_MR_MENU_START"
    echo

    while IFS=$'\n' read -r menu_item; do
        local mr_url mr_title project_name
        eval "$(echo "$menu_item" | jq -r '
            "mr_url="       + (.web_url      | @sh) + ";\n" +
            "mr_title="     + (.title        | @sh) + ";\n" +
            "project_name=" + (.project_name | @sh) + ";\n"
        ')"

        [[ -n $project_name && $project_name != "null" ]] || # Fallback to URL portion
            project_name=$(gitlab_extract_project_url_part "$mr_url")

        mr_title=$(gitlab_title_undraft "$mr_title")

        local item_label; item_label="${project_name}: $(markdown_link "$mr_title" "$mr_url")"

        local wrap=''
        [[ $current_mr_url == "$mr_url" ]] &&
            wrap='**' # Markdown bold

        echo "* ${wrap}${item_label}${wrap}"
    done < <(echo "$menu_items")

    echo
    echo "$GIT_MR_MENU_END"
}

mr_menu_print_title() {
    local issue_code=$1
    local issue_title=$2
    local issue_url=$3
    local menu_items=$4
    local current_index=$5

    local search_url; search_url="https://${GITLAB_DOMAIN}/dashboard/merge_requests?scope=all&state=all&search=$(urlencode "$issue_code")&in=title&sort=created_asc"
    local mr_count; mr_count=$(echo "$menu_items" | wc -l | tr -d ' ')

    echo "================================================================================"
    if [[ -n $issue_title ]] && [[ -n $issue_url ]]; then
        echo " $(terminal_link "$search_url" "$issue_code") $(terminal_link "$issue_url" "$issue_title")  (${mr_count} merge request$([[ $mr_count -gt 1 ]] && echo 's'))"
        has_links || echolor " ⇒ $issue_url" "midgray"
    else
        [[ -z $current_index ]] &&
            echo " $(terminal_link "$search_url" "$issue_code") (${mr_count} merge request$([[ $mr_count -gt 1 ]] && echo 's'))" ||
            echo " $(terminal_link "$search_url" "$issue_code") (merge request ${current_index}/${mr_count})"
    fi
    echo "================================================================================"
}

mr_menu_status() {
    local issue_code=$1
    local menu_items=$2

    local issue_content issue_key issue_title issue_url
    issue_content=$(jira_ticket_data "$issue_code")
    eval "$(echo "$issue_content" | jq -r '
        "issue_key="   + (.key            // empty | @sh) + ";\n" +
        "issue_title=" + (.fields.summary // empty | @sh) + ";\n"
    ')"
    [[ -n $issue_title ]] && issue_url="https://${JIRA_INSTANCE}/browse/${issue_key}"

    echo
    mr_menu_print_title "$issue_code" "$issue_title" "$issue_url" "$menu_items"
    echo

    while IFS= read -r menu_item; do

        local mr_iid mr_url mr_title project_name
        eval "$(echo "$menu_item" | jq -r '
            "mr_iid="       + (.iid          | @sh) + ";\n" +
            "mr_url="       + (.web_url      | @sh) + ";\n" +
            "mr_title="     + (.title        | @sh) + ";\n" +
            "project_name=" + (.project_name | @sh) + ";\n"
        ')"

        local project_url; project_url=$(gitlab_extract_project_url_part "$mr_url")

        [[ -n $project_name && $project_name != "null" ]] || project_name="$project_url" # Fallback to URL portion

        # Load merge request & threads in parallel
        gitlab_load_mr "$mr_iid" "$project_url"
        gitlab_load_threads "$mr_url"

        mr_title=$(gitlab_title_undraft "$mr_title")

        echo -n "* $(colorize "$project_name" "bold"): "
        if has_links; then
            echolink "$mr_url" "$mr_title"
        else
            echo "$mr_title"
            echolor "  ⇒ $mr_url" "midgray"
        fi

        # Read MR & threads
        local merge_request mr_threads
        gitlab_read_mr merge_request
        gitlab_read_threads mr_threads

        mr_print_status "$merge_request" "$mr_threads"
        echo

    done <<<"$menu_items"
}

mr_menu_show() {
    local issue_code=$1
    local menu_items=$2

    echo
    mr_menu_print_title "$issue_code" "" "" "$menu_items"
    echo

    mr_menu_contents "$menu_items"
}

mr_menu_update() {
    git_mr_readonly show

    local menu_items=$1

    local current_branch; current_branch=$(git_current_branch)

    # Search existing merge request
    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$current_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"
        echo
        mr_menu_contents "$menu_items"
        return "$ERR_GITLAB"
    fi

    local mr_iid mr_url
    eval "$(echo "$mr_summary" | jq -r '
        "mr_iid=" + (.iid     | @sh) + ";\n" +
        "mr_url=" + (.web_url | @sh) + ";\n"
    ')"

    # Load existing merge request details
    local merge_request;  merge_request=$(gitlab_merge_request "$mr_iid")

    local mr_title mr_description
    eval "$(echo "$merge_request" | jq -r '
        "mr_title="       + (.title       | @sh) + ";\n" +
        "mr_description=" + (.description | @sh) + ";\n"
    ')"

    local mr_menu_content; mr_menu_content=$(mr_menu_contents "$menu_items" "$mr_url")
    local updated_description; updated_description="$(mr_menu_replace_description "$mr_description" "$mr_menu_content")"

    mr_menu_print_description "$updated_description" "$mr_url" "$mr_title"

    local mr_update_data='{}'
    if confirm "Do you want to update the menu in the merge request description?"; then
        mr_update_data=$(jq_build "description" "$updated_description" "$mr_update_data") || exit "$ERR_MR"
    fi
    if [[ $mr_update_data != "{}" ]]; then
        echo -n "Updating merge request..."
        local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_update_data")
        [[ -n $result ]] && echo -e "OK\n"
    fi
}

mr_menu_update_all() {
    git_mr_readonly show

    local issue_code=$1
    local menu_items=$2

    local mr_iid \
        mr_url \
        mr_title \
        project_name \
        project_url \
        merge_request \
        mr_description \
        mr_menu_content \
        updated_description \
        mr_update_data \
        result

    # Use array instead of looping over variable content with `read` to leave standard input open for `confirm`
    local menu_array
    readarray menu_array < <(echo "$menu_items")

    local i=1 updated_count=0
    for menu_item in "${menu_array[@]}"; do

        eval "$(echo "$menu_item" | jq -r '
            "mr_iid="       + (.iid          | @sh) + ";\n" +
            "mr_url="       + (.web_url      | @sh) + ";\n" +
            "mr_title="     + (.title        | @sh) + ";\n" +
            "project_name=" + (.project_name | @sh) + ";\n"
        ')"

        project_url=$(gitlab_extract_project_url_part "$mr_url")

        [[ -n $project_name && $project_name != "null" ]] || project_name="$project_url" # Fallback to URL portion

        # Load existing merge request details
        merge_request=$(gitlab_merge_request "$mr_iid" "$project_url")

        mr_description=$(gitlab_extract_description "$merge_request")

        mr_menu_content=$(mr_menu_contents "$menu_items" "$mr_url")
        updated_description="$(mr_menu_replace_description "$mr_description" "$mr_menu_content")"

        clear_screen
        mr_menu_print_title "$issue_code" "" "" "$menu_items" "$i"
        mr_menu_print_description "$updated_description" "$mr_url" "$mr_title" "$project_name"

        mr_update_data='{}'
        if confirm "Do you want to update the menu in the merge request description?"; then
            mr_update_data=$(jq_build "description" "$updated_description" "$mr_update_data") || exit "$ERR_MR"
        fi
        if [[ $mr_update_data != "{}" ]]; then
            echo -n "Updating merge request..."
            result=$(gitlab_merge_request_update "$mr_iid" "$mr_update_data" "$project_url")
            [[ -n $result ]] &&
                ((updated_count += 1)) &&
                echo -e "OK\n"
        else
            echo
        fi
        ((i += 1))
    done

    [[ $updated_count -gt 0 ]] &&
        echo "${updated_count} merge request$([[ $updated_count -gt 1 ]] && echo 's') updated"
}

mr_menu_start_line() {
    local mr_description=$1

    echo "$mr_description" | grep -n "$GIT_MR_MENU_START" -m 1 | cut -d: -f1
}

mr_menu_end_line() {
    local mr_description=$1
    local menu_start=${2:-1}

    local menu_end
    menu_end=$(echo "$mr_description" | tail -n +"$((menu_start + 1))" | grep -n -m 1 -- "$GIT_MR_MENU_END" | cut -d: -f1)

    echo $((menu_start + menu_end))
}

mr_menu_replace_description() {
    local mr_description=$1
    local menu_content=$2

    local menu_start; menu_start=$(mr_menu_start_line "$mr_description")
    local menu_end; menu_end=$(mr_menu_end_line "$mr_description" "$menu_start")

    local has_menu=0
    [[ -n $menu_start && -n $menu_end ]] &&
    [[ $menu_start -gt 0 && $menu_end -gt "$menu_start" ]] &&
        has_menu=1

    local menu_was_output=0

    # Iterate over description lines and insert/replace menu
    local i=1 mr_description_line prev_description_line
    while IFS=$'\n' read -r mr_description_line; do
        if [[ $has_menu -eq 1 ]]; then
            if [[ $i -lt "$menu_start" || $i -gt "$menu_end" ]]; then
                # output non-menu line
                echo "$mr_description_line"
            else
                # replace menu once
                if [[ $i -eq "$menu_end" ]]; then
                    echo_debug "Replacing menu"
                    echo "$menu_content"
                    menu_was_output=1
                fi
            fi
        else
            # output non-menu line
            echo "$mr_description_line"
            # insert menu once
            if [[ $menu_was_output -eq 0 && -z "$mr_description_line" && $i -gt 1 ]]; then
                echo_debug "Inserting menu"
                echo "$menu_content"
                echo
                menu_was_output=1
            fi
        fi

        prev_description_line="$mr_description_line"
        ((i += 1))
    done < <(echo "$mr_description")

    if [[ $menu_was_output -eq 0 ]]; then
        echo_debug "Inserting menu (failsafe)"
        [[ -n "$prev_description_line" ]] && echo
        echo "$menu_content"
    fi
}

mr_menu_colorize() {
    local mr_description=$1
    local current_mr_url=$2
    local menu_start=$3
    local menu_end=$4

    # Iterate over description lines and colorize menu lines
    local i=1 mr_description_line
    while IFS=$'\n' read -r mr_description_line; do
        if [[ $i -lt "$menu_start" || $i -gt "$menu_end" ]]; then
            # output non-menu line
            echo -e "$(colorize "$mr_description_line" "lightgray")"
        else
            # colorize menu line
            [[ $mr_description_line =~ $current_mr_url ]] &&
                echo -e "$(colorize "$mr_description_line" "bold" "lightyellow")" ||
                echo -e "$(colorize "$mr_description_line" "lightyellow")"
        fi
        ((i += 1))
    done < <(echo "$mr_description")
}

mr_menu_print_description() {
    local mr_description=$1
    local mr_url=$2
    local mr_title=$3
    local project_name=$4

    local menu_start; menu_start=$(mr_menu_start_line "$mr_description")
    local menu_end; menu_end=$(mr_menu_end_line "$mr_description" "$menu_start")

    echo
    echo "--------------------------------------------------------------------------------"
    echo -n " "
    [[ -n $project_name ]] && echo -n "$(colorize "$project_name" "bold"): "
    echolink "$mr_url" "$(gitlab_title_undraft "$mr_title")"
    echo "--------------------------------------------------------------------------------"
    echo

    mr_menu_colorize "$mr_description" "$mr_url" "$menu_start" "$menu_end" |
        head -n$((menu_end + GIT_MR_MENU_UPDATE_CONTEXT_LINES)) # truncate description after menu

    local desc_len; desc_len=$(echo "$mr_description" | wc -l)
    if [[ $((desc_len - menu_end)) -gt $GIT_MR_MENU_UPDATE_CONTEXT_LINES ]]; then
        echo
        echo "[...]"
    fi

    echo
    echo "--------------------------------------------------------------------------------"
}


################################################################################
# Merge request top-level functions

mr_print() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}
    git_check_branches "$source_branch" "$target_branch"

    local issue_code=${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}
    [[ -n $issue_code ]] || git_mr_unguessable_issue_code=1

    cat <<EOF

--------------------------------------------------------------------------------
$(mr_description "$source_branch" "$target_branch" "$issue_code")

EOF

    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -n $mr_summary ]]; then
        # Print merge request status summary
        mr_status_block "$mr_summary"
    else
        echo "--------------------------------------------------------------------------------"
        echo

        local new_mr_url; new_mr_url=$(gitlab_new_merge_request_url "$source_branch" "$target_branch")
        [[ -n $new_mr_url ]] || return

        cat <<EOF
To create a new merge request:

  ${new_mr_url}

EOF
    fi
}

mr_open() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}

    local issue_code=${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}
    [[ -n $issue_code ]] || git_mr_unguessable_issue_code=1

    local description;
    if [[ -n $target_branch ]]; then
        description=$(mr_description "$source_branch" "$target_branch" "$issue_code")
        cat <<EOF

--------------------------------------------------------------------------------
$description

EOF
    fi

    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -n $mr_summary ]]; then
        open_in_browser "$(gitlab_extract_url "$mr_summary")"

        # Print merge request status summary
        mr_status_block "$mr_summary"
    else
        git_check_branches "$source_branch" "$target_branch"

        echo "--------------------------------------------------------------------------------"
        echo

        local new_mr_url; new_mr_url=$(gitlab_new_merge_request_url "$source_branch" "$target_branch")
        [[ -n $new_mr_url ]] || return

        # add description
        new_mr_url="${new_mr_url}&$(urlencode "merge_request[description]")=$(urlencode "$description")"

        echo_debug
        echo_debug "Opening:"
        echo_debug "$new_mr_url"

        open_in_browser "$new_mr_url"
    fi
}

mr_status() {
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    # Search existing merge request
    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"

        git_check_branches "$source_branch" "-"
        mr_print "$source_branch"
        return "$ERR_GITLAB"
    fi

    # Print merge request title & status
    echo
    mr_status_block "$mr_summary"
}

mr_update() {
    git_mr_readonly show
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}
    git_check_branches "$source_branch" "$target_branch"

    # Search existing merge request
    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"
        mr_print "$source_branch" "$target_branch"
        return "$ERR_GITLAB"
    fi

    local mr_iid mr_url mr_title mr_description
    eval "$(echo "$mr_summary" | jq -r '
        "mr_iid="         + (.iid         | @sh) + ";\n" +
        "mr_url="         + (.web_url     | @sh) + ";\n" +
        "mr_title="       + (.title       | @sh) + ";\n" +
        "mr_description=" + (.description | @sh) + ";\n"
    ')"

    # Load merge request & threads in parallel
    gitlab_load_mr "$mr_iid"
    gitlab_load_threads "$mr_url"

    # Init commit lists

    local commit_messages; commit_messages=$(git_commits "$source_branch" "$target_branch")

    local current_commits; current_commits=$(echo "$commit_messages" | cut -d ' ' -f1)
    local old_commits;     old_commits=$(echo "$mr_description" |
        grep -Po '^[^0-9a-fA-F]*[0-9a-fA-F]{7,}\s' |
        sed -r 's/^[^0-9a-fA-F]*([0-9a-fA-F]{7,})\s/\1/g')

    local old_commits_array current_commits_array oIFS
    oIFS=$IFS; IFS=$'\n'
        # shellcheck disable=SC2206
        current_commits_array=($current_commits)
        # shellcheck disable=SC2206
        old_commits_array=($old_commits)
    IFS=$oIFS

    # Prepare full commit list replacement
    local last_commit_line
    if [[ $GIT_MR_REPLACE_COMMITS -eq 1 ]]; then
        local commits_start_line; commits_start_line=$(mr_description_first_commit_line "$mr_description")
        local commits_end_line; commits_end_line=$(mr_description_last_commit_line "$mr_description")

        if [[ $commits_start_line -gt 0 && $commits_end_line -gt 0 ]]; then
            # Remove old commits from description, keeping leading and/or trailing blank lines
            IFS= read -rd '' mr_description < <(echo "$mr_description" | sed "${commits_start_line},${commits_end_line}d")
            # Remember line where to insert new commits
            last_commit_line=$((commits_start_line - 1)); [[ $last_commit_line -ge 1 ]] || last_commit_line=1
        fi

        # All MR commits will be added as new commits
        old_commits_array=()
    fi

    local updated_commit_count=0
    local new_commit=
    local new_commit_messages_display=()
    local new_commit_messages_content=()

    local new_description_display="$mr_description"
    local new_description_content="$mr_description"

    local sameColor="lightblue"
    local updatedColor="orange"
    local newColor="green"
    local wrongColor="lightred"

    # Iterate over commit lists, compare sha-1 and update description
    for i in ${!current_commits_array[*]}; do

        local curr=${current_commits_array[$i]}
        local old=${old_commits_array[$i]}

        if [[ -n $old ]]; then
            if [[ $old == "$curr" ]]; then
                # same sha-1 - only decorate
                new_description_display=${new_description_display//"$old"/"$(colorize "$curr" "$sameColor")"}
                new_description_content=${new_description_content//"$old"/"$curr"}
            else
                # different sha-1 - replace & decorate
                new_description_display=${new_description_display//"$old"/"$(colorize "$curr" "$updatedColor")"}
                new_description_content=${new_description_content//"$old"/"$curr"}
                updated_commit_count=$((updated_commit_count + 1))
            fi
        else
            # new commit
            [[ $GIT_MR_EXTENDED -eq 1 ]] &&
                new_commit="$(git_commit_extended "$curr")" ||
                new_commit="$(echo "$commit_messages" | grep "$curr")"

            new_commit_messages_display+=("${new_commit//"$curr"/$(colorize "$curr" "$newColor")}")
            new_commit_messages_content+=("$new_commit")
        fi
    done

    local old_commit_count=${#old_commits_array[@]}
    local current_commit_count=${#current_commits_array[@]}
    local new_commit_count=${#new_commit_messages_content[@]}
    local unknown_commit_count=$((old_commit_count - current_commit_count))

    if [[ $unknown_commit_count -gt 0 ]]; then
        for (( i = current_commit_count; i < old_commit_count; i++ )); do
            old="${old_commits_array[$i]}"
            new_description_display=${new_description_display//"$old"/"$(colorize "$old" "$wrongColor")"}
        done
    fi

    # implode arrays
    local new_commit_messages_display_str; new_commit_messages_display_str=$(printf "%s\n" "${new_commit_messages_display[@]}")
    local new_commit_messages_content_str; new_commit_messages_content_str=$(printf "%s\n" "${new_commit_messages_content[@]}")

    if [[ $new_commit_count -gt 0 ]]; then
        # Find last commit line in current description (when not replacing whole commit list)
        [[ -z $last_commit_line ]] &&
            last_commit_line=$(mr_description_last_commit_line "$mr_description")

        new_description_display=$(mr_description_insert_new_commits "$new_description_display" "$new_commit_messages_display_str" "$last_commit_line" true)
        new_description_content=$(mr_description_insert_new_commits "$new_description_content" "$new_commit_messages_content_str" "$last_commit_line")
    fi

    # Print updated merge request description
    echo
    mr_print_title "$mr_title" "$mr_url"
    echo
    echo "$new_description_display"
    echo
    echo "--------------------------------------------------------------------------------"
    echo
    echo "  updated commits: $(colorize "$updated_commit_count" "$updatedColor")"
    echo "      new commits: $(colorize "$new_commit_count"     "$newColor")"
    if [[ $unknown_commit_count -gt 0 ]]; then
        echo
        echo "  unknown commits: $(colorize "$unknown_commit_count" "$wrongColor")"
    fi
    echo

    # Propose update if changes are detected

    local mr_update_data='{}' update_prompt

    if [[ $unknown_commit_count -gt 0 ]]; then
        echo_error "Current description has ${unknown_commit_count} more commit(s) than found in branch, given target '${target_branch}'."
        echo_error "You might want to check your target branch or update the description manually."
        echo_error
    fi

    if [[ $((updated_commit_count + new_commit_count)) -gt 0 ]]; then
        update_prompt=1

        local remote; remote=$(gitlab_remote)
        local remote_branch="${remote}/${source_branch}"

        local should_update_description=0
        if [[ "$(git rev-parse "$source_branch")" != "$(git rev-parse "$remote_branch")" ]]; then
            echo_error "Remote branch on ${remote} is not up-to-date with local branch ${source_branch}."
            if confirm "Update merge request description anyway?"; then
                should_update_description=1
            fi
        elif confirm "Do you want to update the merge request description?"; then
            should_update_description=1
        fi

        if [[ $should_update_description -eq 1 ]]; then
            mr_update_data=$(jq_build "description" "$new_description_content" "$mr_update_data") || exit "$ERR_MR"
        fi
    fi

    # Read existing merge request details
    local merge_request
    gitlab_read_mr merge_request

    local current_target
    eval "$(echo "$merge_request" | jq -r '
        "current_target=" + (.target_branch | @sh) + ";\n"
    ')"

    if [[ $target_branch != "$current_target" ]]; then
        if git_branch_exists "$target_branch"; then
            update_prompt=1
            if confirm "Do you want to update the merge request target branch from '$current_target' to '$target_branch'?"; then
                if git_remote_branch_exists "$target_branch"; then
                    mr_update_data=$(jq_build "target_branch" "$target_branch" "$mr_update_data") || exit "$ERR_MR"
                else
                    echo_error "Target branch '$target_branch' does not exist on remote."
                    [[ $mr_update_data != '{}' ]] && ! confirm "Update description anyway?" && mr_update_data="{}"
                fi
            fi
        elif git cat-file -e "$target_branch" 2>/dev/null; then
            echo_error
            echo_error "Guessed target '$target_branch' is a commit reference."
            echo_error "(No local base branch found, first possible merge base used.)"
            echo_error "You might need to rebase your branch."
            [[ $mr_update_data != '{}' ]] && ! confirm "Update description anyway?" && mr_update_data="{}"
        else
            echo_error "Target '$target_branch' does not exist."
            [[ $mr_update_data != '{}' ]] && ! confirm "Update description anyway?" && mr_update_data="{}"
        fi
    fi

    if [[ $mr_update_data != "{}" ]]; then
        echo -n "Updating merge request..."

        local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_update_data")
        [[ -n $result ]] && echo -e "OK\n"

        # reload merge request details
        merge_request=
        gitlab_load_mr "$mr_iid"
    else
        [[ -n $update_prompt ]] && echo
    fi

    # Read MR & threads
    local mr_threads
    [[ -n $merge_request ]] ||
        gitlab_read_mr merge_request
    gitlab_read_threads mr_threads

    # --------------------------------------------------------------------------------
    mr_print_title "$mr_title" "$mr_url"
    mr_print_status "$merge_request" "$mr_threads"
}

mr_merge() {
    git_mr_readonly show
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    # Search existing merge request
    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"
        mr_print "$source_branch"
        return "$ERR_GITLAB"
    fi

    local mr_iid mr_url mr_title
    eval "$(echo "$mr_summary" | jq -r '
        "mr_iid="   + (.iid     | @sh) + ";\n" +
        "mr_url="   + (.web_url | @sh) + ";\n" +
        "mr_title=" + (.title   | @sh) + ";\n"
    ')"

    # Load merge request & threads in parallel
    gitlab_load_mr "$mr_iid"
    gitlab_load_threads "$mr_url"

    # Merge request status summary - title
    echo
    mr_print_title "$mr_title" "$mr_url"

    # Read MR & threads
    local merge_request mr_threads
    gitlab_read_mr merge_request
    gitlab_read_threads mr_threads

    # Merge request status summary - status
    mr_print_status "$merge_request" "$mr_threads"

    echo "--------------------------------------------------------------------------------"
    echo

    # Parse merge status
    local merge_status current_target
    eval "$(echo "$merge_request" | jq -r '
        "merge_status="   + (if .state == "merged"
                             then "merged"
                             else .merge_status end | @sh) + ";\n" +
        "current_target=" + (.target_branch | @sh)         + ";\n"
    ')"

    # Test merge status
    if [[ $merge_status == "merged" ]]; then
        echo_error "Merge request is already merged."
        echo_error
        return 0
    fi
    if [[ $merge_status != "can_be_merged" ]]; then
        echo_error "Merge request can not be merged. You probably need to rebase the branch and resolve conflicts."
        echo_error
        return "$ERR_GITLAB"
    fi

    # test open threads
    local unresolved_thread_count; unresolved_thread_count=$(echo "$mr_threads" | grep -c 'unresolved:true')
    if [[ $unresolved_thread_count -gt 0 ]]; then
        if [[ $GIT_MR_FORCE -eq 1 ]]; then
            echo_error "There are $unresolved_thread_count unresolved threads. Merging anyway."
            echo_error
        else
            echo_error "There are $unresolved_thread_count unresolved threads. Please resolve them before merging or use the --force option."
            echo_error
            return "$ERR_USER"
        fi
    fi

    if gitlab_title_is_draft "$mr_title"; then
        echo_error "Merge request is a draft (work in progress)"
        confirm "Do you want to resolve draft status?" || { echo_error; return 0; }

        echo -n "Resolving draft status... "
        local undraft_title; undraft_title=$(gitlab_title_undraft "$mr_title")
        local mr_data;       mr_data=$(jq_build "title" "$undraft_title") || exit "$ERR_MR"

        local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_data")
        [[ -n $result ]] && echo -e "OK\n"

        [[ -n $result ]] || { echo_error; return "$ERR_GITLAB"; } # interrupt on error
    fi

    # Merge

    confirm "Do you want to merge '$source_branch' into '$current_target'?" || { echo; return 0; }

    echo -n "Merging '$source_branch'... "
    local result; result=$(gitlab_merge_request_merge "${mr_iid}")
    [[ -n $result ]] && echo -e "OK\n"

    [[ -n $result ]] || { echo_error; return "$ERR_GITLAB"; } # interrupt on error

    # checkout target branch

    confirm "Do you want to checkout '$current_target' and pull changes?" || { echo; return 0; }

    echolor "git checkout $current_target && git pull --rebase" "lightgray"
    git_mr_readonly ||
        (git checkout "$current_target" && git pull --rebase)
    echo

    # delete local branch

    confirm "Do you want to delete local branch '$source_branch'?" || { echo; return 0; }

    echolor "git branch -d $source_branch" "lightgray"
    git_mr_readonly ||
        git branch -d "$source_branch"
    echo
}

mr_menu() {
    gitlab_check_env

    local git_mr_menu_mode=show
    local git_mr_menu_update_all=1

    # Parse options
    args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
        # Consume options
        up|update)   git_mr_menu_mode=update ;;
        --current)   git_mr_menu_update_all=0 ;;
        st|status)   git_mr_menu_mode=status ;;
        # Default: conserve argument
        *) args+=("${1}") ;;
        esac
        shift
    done
    set -- "${args[@]}"

    local source_branch; source_branch=$(git_current_branch)
    local issue_code=${GIT_MR_CODE:-${1:-$(guess_issue_code "$source_branch")}}

    [[ -n $issue_code ]] || exit_error "$ERR_USER" "Issue code or search term required for menu."

    # All non-closed merge requests for issue code
    local menu_items; menu_items=$(mr_menu_merge_requests "$issue_code")

    if [[ -z $menu_items ]]; then
        echo_error "No merge requests found for '$issue_code'."
        return "$ERR_GITLAB"
    fi

    case "$git_mr_menu_mode" in
        show) mr_menu_show "$issue_code" "$menu_items" ;;
        update) if [[ $git_mr_menu_update_all -eq 1 ]]
            then mr_menu_update_all "$issue_code" "$menu_items"
            else mr_menu_update     "$menu_items"; fi ;;
        status) mr_menu_status "$issue_code" "$menu_items" ;;
        *) return "$ERR_MR" ;;
    esac
}

mr_transition() {
    git_mr_readonly show

    local transition=${1}
    local source_branch=${2:-$(git_current_branch)}

    local issue_code=${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}

    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"
        mr_print "$source_branch"
        return "$ERR_GITLAB"
    fi

    local mr_iid mr_url mr_title
    eval "$(echo "$mr_summary" | jq -r '
        "mr_iid="   + (.iid     | @sh) + ";\n" +
        "mr_url="   + (.web_url | @sh) + ";\n" +
        "mr_title=" + (.title   | @sh) + ";\n"
    ')"

    # Load merge request & threads in parallel
    gitlab_load_mr "$mr_iid"
    gitlab_load_threads "$mr_url"

    local name labels_to_add labels_to_remove jira_transition_var
    case "$transition" in
        IP)
            name="In Progress"
            labels_to_add="${GITLAB_IP_LABELS}"
            labels_to_remove=$(trim "${GITLAB_CR_LABELS},${GITLAB_QA_LABELS},${GITLAB_OK_LABELS}" ",")
            jira_transition_var="JIRA_IP_ID"
            ;;
        CR)
            name="Code Review"
            labels_to_add="${GITLAB_CR_LABELS}"
            labels_to_remove=$(trim "${GITLAB_IP_LABELS},${GITLAB_QA_LABELS},${GITLAB_OK_LABELS}" ",")
            jira_transition_var="JIRA_CR_ID"
            ;;
        QA)
            name="Quality Assurance"
            labels_to_add="${GITLAB_QA_LABELS}"
            labels_to_remove=$(trim "${GITLAB_IP_LABELS},${GITLAB_CR_LABELS},${GITLAB_OK_LABELS}" ",")
            jira_transition_var="JIRA_QA_ID"
            ;;
        OK)
            name="Accepted"
            labels_to_add="${GITLAB_OK_LABELS}"
            labels_to_remove=$(trim "${GITLAB_IP_LABELS},${GITLAB_CR_LABELS},${GITLAB_QA_LABELS}" ",")
            jira_transition_var="JIRA_OK_ID"
            ;;
        *)
            echo_error "Invalid transition"
            return "$ERR_JIRA"
            ;;
    esac

    # Merge request status summary - title
    echo
    mr_print_title "$mr_title" "$mr_url"

    # Read MR & threads
    local merge_request mr_threads
    gitlab_read_mr merge_request
    gitlab_read_threads mr_threads

    # Merge request status summary - status
    mr_print_status "$merge_request" "$mr_threads"

    echo "--------------------------------------------------------------------------------"
    echo

    mr_update_labels "$mr_iid" "$(gitlab_extract_labels "$merge_request")" "$labels_to_remove" "$labels_to_add"

    [[ $transition == "IP" ]] &&
        mr_gitlab_draft "$mr_iid" "$mr_summary"
    [[ $transition == "OK" ]] &&
        mr_gitlab_undraft "$mr_iid" "$mr_summary"

    mr_jira_transition "$issue_code" "$name" "$jira_transition_var"
}

mr_hook() {
    git_mr_readonly show

    local git_dir; git_dir=$(git rev-parse --git-dir)
    local git_mr_dir; git_mr_dir="$(dirname "${BASH_SOURCE[0]}")"

    [[ -d "${git_dir}/hooks" ]] || mkdir "${git_dir}/hooks"

    local hook
    while read -r -d $'\0' hook; do
        local hook_name; hook_name="$(basename "$hook")"
        echo "Linking hook: ${hook_name}"
        git_mr_readonly ||
            ln -sf "$hook" "${git_dir}/hooks/${hook_name}"
    done < <(find "${git_mr_dir}/hooks" -type f -print0)
}

usage() {
    local b; b="$(printf '\e[1m')"
    local i; i="$(printf '\e[3m')"
    local u; u="$(printf '\e[4m')"
    local r; r="$(printf '\e[0m')"

    cat <<EOF
${b}NAME${r}
       ${u}git-mr${r} - Manage a Gitlab merge request description, with link to Jira ticket and current branch commit list

${b}SYNOPSIS${r}
       ${u}git${r} ${u}mr${r} [OPTION...]          [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  open    [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  status  [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  update  [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  merge   [BRANCH]

       ${u}git${r} ${u}mr${r} [OPTION...]  menu                     [SEARCH_TERM]
       ${u}git${r} ${u}mr${r} [OPTION...]  menu update [--current]  [SEARCH_TERM]
       ${u}git${r} ${u}mr${r} [OPTION...]  menu status              [SEARCH_TERM]

       ${u}git${r} ${u}mr${r} [OPTION...]  (ip|cr|qa|ok)  [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  undraft        [BRANCH]

       ${u}git${r} ${u}mr${r}  base  [BRANCH]
       ${u}git${r} ${u}mr${r}  code  [BRANCH]

       ${u}git${r} ${u}mr${r}  hook

${b}ARGUMENTS${r}
       BRANCH
           Merge request source branch.
           (Defaults to current branch.)

       SEARCH_TERM
           Term searched in merge requests titles to build menu.
           (Defaults to Jira issue code guessed from branch name.)

${b}OPTIONS${r}
       -c, --code   ISSUE_CODE
           Force issue code.

       -t, --target TARGET_BRANCH
           Force target branch.

       -e, --extended
           Use full commit messages in description ("extended", for \`git mr [open|update]\`).
           You can also set GIT_MR_EXTENDED=1 in your environment variables to always use extended commit descriptions.

       --no-color
           Disable terminal colors.

       --no-links
           Disable terminal hyperlinks and show merge request URL in \`mr status\` and \`mr menu status\`.

       -y, --yes
           Bypass confirmation prompts ("yes").

       -v, --verbose
           Verbose output (displays called API URLs & other debugging info).

       -h
           Show this help.

${b}COMMAND-SPECIFIC OPTIONS${r}

   ${b}git mr update${r}

       -n, --new-section [NEW_SECTION_TITLE]
           Add new section in description for new commits.

       -r, --replace-commits
           Fully replace commit list in description with current commits.

   ${b}git mr menu update${r}

       --current
           Update only current project/branch merge request.

   ${b}git mr merge${r}

       -f, --force
           Force merge even if there are unresolved threads.

${b}CONFIGURATION${r}
EOF
    if [[ $GIT_MR_VERBOSE -eq 1 ]]; then
        cat <<EOF

       Configuration reference:

       +---------------------------------------------+---------------------------------------+
       | ${b}git configuration${r} (${i} git config [--global]${r} ) | ${b}environment variables${r}                 |
       +---------------------------------------------+---------------------------------------+
       | mr.jira-instance                            | JIRA_INSTANCE                         |
       | mr.jira-user                                | JIRA_USER                             |
       | mr.jira-token                               | JIRA_TOKEN                            |
       | mr.jira-code-pattern                        | JIRA_CODE_PATTERN                     |
       |                                             |                                       |
       | mr.gitlab-domain                            | GITLAB_DOMAIN                         |
       | mr.gitlab-token                             | GITLAB_TOKEN                          |
       +---------------------------------------------+---------------------------------------+
       | mr.gitlab-default-labels                    | GITLAB_DEFAULT_LABELS                 |
       |                                             |                                       |
       | mr.gitlab-ip-labels                         | GITLAB_IP_LABELS                      |
       | mr.gitlab-cr-labels                         | GITLAB_CR_LABELS                      |
       | mr.gitlab-qa-labels                         | GITLAB_QA_LABELS                      |
       | mr.gitlab-ok-labels                         | GITLAB_OK_LABELS                      |
       |                                             |                                       |
       | mr.gitlab-remove-source-branch-on-merge     | GITLAB_REMOVE_SOURCE_BRANCH_ON_MERGE  |
       |                                             |                                       |
       | mr.jira-ip-id                               | JIRA_IP_ID                            |
       | mr.jira-cr-id                               | JIRA_CR_ID                            |
       | mr.jira-qa-id                               | JIRA_QA_ID                            |
       | mr.jira-ok-id                               | JIRA_OK_ID                            |
       |                                             |                                       |
       | mr.git-mr-extended                          | GIT_MR_EXTENDED                       |
       |                                             |                                       |
       | mr.git-mr-required-upvotes                  | GIT_MR_REQUIRED_UPVOTES               |
       |                                             |                                       |
       | mr.git-mr-timeout                           | GIT_MR_TIMEOUT                        |
       +---------------------------------------------+---------------------------------------+

       To create a Jira API Token, go to: https://id.atlassian.com/manage-profile/security/api-tokens
       (Account Settings -> Security -> API Token -> Create and manage API tokens)

       To create a Gitlab API Token, go to: https://myapp.gitlab.com/-/profile/personal_access_tokens?name=Git-MR+Access+token&scopes=api
       (Settings -> Access Tokens)

EOF
    else
        cat <<EOF
       ${i}Use the -v|--verbose option to show configuration options.${r}

EOF
    fi

    cat <<EOF
${b}HOMEPAGE${r}
       https://github.com/Djuuu/git-mr

EOF
}


################################################################################
# Error codes

#ERR=1             # General error
ERR_USER=9         # User error
ERR_GIT=10         # Git error
ERR_GIT_REPO=11    # Git repository error
ERR_GITLAB=20      # Gitlab error
ERR_GITLAB_API=21  # Gitlab request error
ERR_JIRA=30        # Jira error
ERR_JIRA_API=31    # Jira request error
ERR_MR=90          # Git-MR error
ERR_MR_DEPS=91     # Dependency issue
ERR_MR_ENV=92      # Environment configuration issue


################################################################################
# Hardcoded constants
GITLAB_DRAFT_PREFIX="Draft"
GITLAB_DRAFT_PREFIXES=("WIP" "Draft")
MD_BOLD=${MD_BOLD="**"} # Markdown bold
MD_BR=${MD_BR="  "} # Markdown line break
GIT_MR_MENU_START=${GIT_MR_MENU_START:-"## Menu"}
GIT_MR_MENU_END=${GIT_MR_MENU_END:-"--------------------------------------------------------------------------------"}
GIT_MR_MENU_UPDATE_CONTEXT_LINES=${GIT_MR_MENU_UPDATE_CONTEXT_LINES:-15}

# Custom file descriptors
git_mr_fd_mr=${GIT_MR_FD_MR=}
git_mr_fd_th=${GIT_MR_FD_TH=}


################################################################################
# Variables

JIRA_INSTANCE=${JIRA_INSTANCE:-$(git config --get mr.jira-instance || true)}
JIRA_USER=${JIRA_USER:-$(        git config --get mr.jira-user     || true)}
JIRA_TOKEN=${JIRA_TOKEN:-$(      git config --get mr.jira-token    || true)}

GITLAB_DOMAIN=${GITLAB_DOMAIN:-$(git config --get mr.gitlab-domain || true)}
GITLAB_TOKEN=${GITLAB_TOKEN:-$(  git config --get mr.gitlab-token  || true)}

JIRA_CODE_PATTERN=${JIRA_CODE_PATTERN:-$(git config --get mr.jira-code-pattern || true)}

JIRA_IP_ID=${JIRA_IP_ID:-$(git config --get mr.jira-ip-id || true)}
JIRA_CR_ID=${JIRA_CR_ID:-$(git config --get mr.jira-cr-id || true)}
JIRA_QA_ID=${JIRA_QA_ID:-$(git config --get mr.jira-qa-id || true)}
JIRA_OK_ID=${JIRA_OK_ID:-$(git config --get mr.jira-ok-id || true)}

GITLAB_IP_LABELS=${GITLAB_IP_LABELS-$(git config --get mr.gitlab-ip-labels || true)}
GITLAB_CR_LABELS=${GITLAB_CR_LABELS-$(git config --get mr.gitlab-cr-labels || true)}
GITLAB_QA_LABELS=${GITLAB_QA_LABELS-$(git config --get mr.gitlab-qa-labels || true)}
GITLAB_OK_LABELS=${GITLAB_OK_LABELS-$(git config --get mr.gitlab-ok-labels || true)}

GITLAB_DEFAULT_LABELS=${GITLAB_DEFAULT_LABELS-$(git config --get mr.gitlab-default-labels || true)}

GIT_MR_EXTENDED=${GIT_MR_EXTENDED-$(git config --get mr.git-mr-extended || true)}

GIT_MR_REQUIRED_UPVOTES=${GIT_MR_REQUIRED_UPVOTES:-$(git config --get mr.git-mr-required-upvotes || true)}
GITLAB_REMOVE_SOURCE_BRANCH_ON_MERGE=${GITLAB_REMOVE_SOURCE_BRANCH_ON_MERGE:-$(git config --get mr.gitlab-remove-source-branch-on-merge || true)}
GIT_MR_TIMEOUT=${GIT_MR_TIMEOUT:-$(git config --get mr.git-mr-timeout || true)}

# Defaults
GIT_MR_REQUIRED_UPVOTES=${GIT_MR_REQUIRED_UPVOTES:-2}
GITLAB_REMOVE_SOURCE_BRANCH_ON_MERGE=${GITLAB_REMOVE_SOURCE_BRANCH_ON_MERGE:-1}
GIT_MR_TIMEOUT=${GIT_MR_TIMEOUT:-5}


################################################################################
# Run

# Exit if not running script directly (ex: when sourcing)
[[ "$(basename "$0")" == 'git-mr' ]] || return 0;

# Init

git rev-parse > /dev/null 2>&1    || exit_error "$ERR_GIT_REPO" "Not a git repository"

[[ -x "$(command -v jq)" ]]       || exit_error "$ERR_MR_DEPS" "Git-MR requires jq [https://stedolan.github.io/jq/]"
[[ "${BASH_VERSINFO:-0}" -ge 4 ]] || exit_error "$ERR_MR_DEPS" "Your bash version is too old: $BASH_VERSION"


# Parse options
args=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -c|--code)   GIT_MR_CODE="$2";   shift ;;
        -t|--target) GIT_MR_TARGET="$2"; shift ;;

        -e|--extended) GIT_MR_EXTENDED=1 ;;

        --no-color) GIT_MR_NO_COLORS=1 ;;
        --no-links) GIT_MR_NO_TERMINAL_LINK=1 ;;

        -y|--yes)     GIT_MR_YES=1 ;;
        -v|--verbose) GIT_MR_VERBOSE=1 ;;
        --no-commits) GIT_MR_NO_COMMITS=1 ;;

        # mr update
        -n|--new-section) GIT_MR_UPDATE_NEW_SECTION=1
            case "$2" in
                -c|--code | -t|--target | -e|--extended | --no-color|--no-links | -y|--yes | -v|--verbose | -r|--replace-commits | -f|--force | -h) ;;
                *) GIT_MR_UPDATE_NEW_SECTION_NAME="$2"; shift ;;
            esac ;;
        -r|--replace-commits) GIT_MR_REPLACE_COMMITS=1 ;;

        # mr merge
        -f|--force) GIT_MR_FORCE=1 ;;

        -h) args=("usage") ;;

        *) args+=("${1}") ;;
    esac
    shift
done
set -- "${args[@]}"


# Run
case $1 in

    help|usage) usage ;;

    o|op|open)   mr_open   "${@:2}" ;;
    s|st|status) mr_status "${@:2}" ;;
    u|up|update) mr_update "${@:2}" ;;
    m|mg|merge)  mr_merge  "${@:2}" ;;

    menu) mr_menu "${@:2}" ;;

    ip|IP) mr_transition "IP" "${@:2}" ;;
    cr|CR) mr_transition "CR" "${@:2}" ;;
    qa|QA) mr_transition "QA" "${@:2}" ;;
    ok|OK) mr_transition "OK" "${@:2}" ;;

    undraft) gitlab_undraft "${@:2}" ;;

    hook) mr_hook ;;

    # Plumbing
    base) git_base_branch "$2" ;;
    code) guess_issue_code "$2" ;;

    *) mr_print "$@" ;;

esac
