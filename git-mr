#!/usr/bin/env bash
# shellcheck disable=SC2001,SC2005
# SC2001: Ignore bash ${variable//search/replace} substitutions suggestions
# SC2005: Ignore useless echo warnings (colorize and other formatting functions don't output a new line)

################################################################################
# Git functions

git_current_branch() {
    # `git branch --show-current` is available starting from Git 2.22
    # fallback to `git rev-parse --abbrev-ref HEAD` if first command fails
    (git branch --show-current 2>/dev/null) ||
        git rev-parse --abbrev-ref HEAD
}

git_base_branch() {
    local branch=${1:-$(git_current_branch)}

    local default_branch; default_branch=$(git_default_branch)

    [[ -n $branch ]]                   || exit "$ERR_GIT" # Not on any branch
    [[ $branch != "$default_branch" ]] || exit "$ERR_GIT" # On default branch
    git show-ref -q --heads "$branch"  || exit "$ERR_GIT" # Branch does not exist

    # Nearest branch in commit history
    local base_branch
    local refs_logs; refs_logs=$(git log --oneline --decorate "${branch}" \
            --simplify-by-decoration --decorate-refs='refs/heads/*') # select only commits with a local branch

    if [[ $(echo "$refs_logs" | wc -l) -gt 1 ]]; then
        base_branch=$( \
            echo "$refs_logs" |
            head -n2 | tail -n1                  | # select closest decoration before current HEAD
            sed 's/[a-f0-9]* (\([^)]*\)) .*/\1/' | # filters out everything but decorations
            sed -e 's/, /\n/g'                   | # splits decorations
            head -n1)                              # keep only first decoration
    fi

    # First possible merge base
    if ! git show-ref -q --heads "$base_branch"; then
        base_branch=$(git show-branch --merge-base "$branch" "$default_branch" | head -n1)
    fi

    echo_debug "Base branch: $base_branch"

    echo "$base_branch"
}

git_remote() {
    git remote | head -n1
}

git_branch_exists() {
    local branch=$1

    git show-ref -q --heads "$branch"
}

git_default_branch() {
    local remote; remote=$(gitlab_remote || git_remote)
    local default; default=$(git symbolic-ref "refs/remotes/${remote}/HEAD" -- 2>/dev/null)

    if [[ -n $default ]]; then

        local local_tracking
        local_tracking=$(git branch -vv | grep "${default#"refs/remotes/"}" | sed 's/^[* ]*//' | cut -d' ' -f1)

        # local branch tracking default remote with a different name
        [[ -n $local_tracking ]] && echo "$local_tracking" && return 0

        # short local name of remote default
        echo "${default#"refs/remotes/${remote}/"}"
        return 0
    fi

    git_branch_exists "main"   && echo "main"   && return 0
    git_branch_exists "master" && echo "master" && return 0
}

git_remote_branch_exists() {
    local branch=$1
    local remote=${2:-$(gitlab_remote)}

    [[ -n "$(git ls-remote --heads "$remote" "$branch")" ]]
}

git_check_branches() {
    local source_branch="$1"
    local target_branch="$2"

    [[ -n $source_branch ]] ||
        exit_error "$ERR_GIT" "Not on any branch"

    [[ $source_branch != "$(git_default_branch)" ]] ||
        exit_error "$ERR_GIT" "On default branch"

    git show-ref -q --heads "$source_branch" ||
        exit_error "$ERR_GIT" "Branch '$source_branch' does not exist"

    [[ -n $target_branch ]] ||
        exit_error "$ERR_GIT" "Unable to determine target branch"

    return 0
}

git_commits() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}

    git log --oneline --reverse --no-decorate "heads/${target_branch}..heads/${source_branch}"
}

git_commits_extended() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}

    local prefix="* ${MD_BOLD}"
    local suffix="${MD_BOLD}${MD_BR}"

    local end="---COMMIT-BODY-END---" # useful to remove trailing blank line

    local format="${prefix}%h %s${suffix}%n%b${end}"

    git log --reverse --no-decorate --format="${format}" "${target_branch}".."${source_branch}" |
        grep -v "^${end}" | # remove trailing blank line
        sed -r "s/${end}$//g" # remove trailing body end for bodies without trailing blank line
}

git_commit_extended() {
    local revision=${1:-HEAD}

    local prefix="* ${MD_BOLD}"
    local suffix="${MD_BOLD}${MD_BR}"

    local end="---COMMIT-BODY-END---" # useful to remove trailing blank line

    local format="${prefix}%h %s${suffix}%n%b${end}"

    git show -s --format="${format}" "${revision}" |
        grep -v "^${end}" | # remove trailing blank line
        sed -r "s/${end}$//g" # remove trailing body end for bodies without trailing blank line
}

git_titlize_branch() {
    local branch=${1:-$(git_current_branch)}

    # Split prefix, issue id & label parts

    local branch_split_pattern="^(.*)($JIRA_CODE_PATTERN)[^a-zA-Z0-9]?(.*)$"

    local prefix;   prefix=$(  echo "$branch" | sed -r "s/$branch_split_pattern/\1/") # ex: 'feature/'
    local issue_id; issue_id=$(echo "$branch" | sed -r "s/$branch_split_pattern/\2/") # ex: 'XY-1234'
    local label;    label=$(   echo "$branch" | sed -r "s/$branch_split_pattern/\3/") # ex: 'my-branch-name'

    # When Jira code pattern is not matched
    if [[ $prefix == "$issue_id" ]]; then
        # Split prefix & label parts
        branch_split_pattern="^([^\/]*\/?)(.*)$"
        prefix=$(echo "$branch" | sed -r "s/$branch_split_pattern/\1/")
        label=$(echo "$branch" | sed -r "s/$branch_split_pattern/\2/")
        issue_id=
    else
        issue_id="$issue_id " # add space
    fi

    # When Jira code pattern and prefix are not matched
    if [[ -z $label ]]; then
        label="$prefix"
        prefix=
    fi

    # Formatting
    local title_ref;   title_ref="${prefix^}${issue_id}"
    local title_label; title_label="$(echo "${label^}" | sed 's/[-_]/ /g')"

    echo "${title_ref}${title_label}"
}


################################################################################
# Misc. utilities

# sed wrapper (use gsed if available on Mac)
sed() {
    if type gsed >/dev/null 2>&1; then
        gsed "$@"
    else
        command sed "$@"
    fi
}

# grep wrapper (use ggrep if available on Mac)
grep() {
    if type ggrep >/dev/null 2>&1; then
        ggrep "$@"
    else
        command grep "$@"
    fi
}

exit_error() {
    local code=$1
    local msg="$2"

    echo_error "$msg"
    exit "$code"
}

# https://gist.github.com/cdown/1163649#gistcomment-1639097
urlencode() {
    local oLANG="$LANG"
    local oLC_ALL="$LC_ALL"
    LANG=C
    LC_ALL=C
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "%s" "$c" ;;
            *) printf '%%%02X' "'$c" ;;
        esac
    done
    LANG="$oLANG"
    LC_ALL="$oLC_ALL"
}

has_terminal_colors() {
    command -v tput > /dev/null 2>&1 &&
    [[ -n $TERM ]] &&
    [[ "$(tput -T"$TERM" colors)" -ge 8 ]]
}

has_colors() {
    [[ $GIT_MR_NO_COLORS -ne 1 ]] && has_terminal_colors
}

has_links() {
    [[ $GIT_MR_NO_TERMINAL_LINK -ne 1 ]] && has_terminal_colors
}

# shellcheck disable=SC2034 # Ignore unused color variables
colorize() {
    local input=$1

    if has_colors; then
        local bold='\e[1m'; local nobold='\e[21m'

        local red='\e[31m';    local lightred='\e[91m'
        local green='\e[32m';  local lightgreen='\e[92m'
        local orange='\e[33m'; local lightyellow='\e[93m'
        local blue='\e[34m';   local lightblue='\e[94m'
        local purple='\e[35m'; local lightpurple='\e[95m'
        local cyan='\e[36m';   local lightcyan='\e[96m'
        local gray='\e[090m';  local lightgray='\e[37m'

        local reset='\e[0m'

        for style in "${@:2}"; do
            echo -en "${!style}"
        done
        echo -en "$input"
        echo -en "$reset"
    else
        echo -en "$input"
    fi
}

# https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda
terminal_link() {
    local href=$1
    local text=$2

    if has_links; then
        printf "\e]8;;%s\e\\%s\e]8;;\e\\" "$href" "$text"
    else
        echo -n "$text"
    fi
}

echo_error() {
    colorize "$1\n" "orange" >&2
}

echo_debug() {
    [[ $GIT_MR_VERBOSE -eq 1 ]] || return 0

    colorize "$1\n" "gray" >&2
}

echo_spacer() {
    local count=$1
    local char=${2:-" "}

    for ((i=1; i <= count; i++)); do
        echo -n "$char"
    done
}

confirm() {
    local question=$1

    if [[ $GIT_MR_YES -eq 1 ]]; then
        echo "$(colorize "${question}" "cyan" >&2) -> yes" >&2
        return 0
    fi

    local response
    read -r -p "$(colorize "$question" "lightcyan" "bold") [y/N] " response
    case "$response" in
        [yY][eE][sS]|[yY]) return 0 ;;
        *)                 return 1 ;;
    esac
}

clear_screen() {
    command -v tput > /dev/null 2>&1 &&
    [[ -n $TERM ]] &&
        tput -x clear
}

jq_build() {
    local key=${1}
    local value=${2}
    local initial_data=${3:-"{}"}

    local is_obj; is_obj=$(echo "$value" | grep '^{.*}$')
    local is_num; is_num=$(echo "$value" | grep '^[0-9]*$')

    local current_object

    if [[ -n $is_obj || -n $is_num ]]; then
        current_object="$(jq --null-input --compact-output --argjson value "$value" "{\"${key}\": \$value}")"
    else
        current_object="$(jq --null-input --compact-output --arg     value "$value" "{\"${key}\": \$value}")"
    fi

    jq --null-input --compact-output \
        --argjson initial_data "$initial_data" \
        --argjson current_object "$current_object" \
        '$initial_data + $current_object'
}

# escape regex special characters for literal usage
regex_escape() {
    echo "${1}" | sed -e 's/[]\/$*.^[]/\\&/g'
}

open_in_browser() {
    local url=$1

    [[ -n $url ]] || return "$ERR_MR"

    local open_command
    if   [[ "$OSTYPE" == "linux-gnu"* ]]; then open_command='xdg-open';
    elif [[ "$OSTYPE" == "darwin"*    ]]; then open_command='open';
    elif [[ "$OSTYPE" == "msys"*      ]]; then open_command='explorer';
    fi

    if [[ -n $open_command && -x "$(command -v "$open_command")" ]]; then
        $open_command "${url}" > /dev/null 2>&1
        return 0
    fi

    echo_error "Unable to open browser"
    echo_error
    echo "${url}"
    echo
    return "$ERR_MR"
}

git_mr_readonly() {
    [[ $GIT_MR_READONLY -eq 1 ]] || return 1

    [[ -n $1 ]] &&
        echo "$(colorize "🚫 Read-only 🚫" "gray")" >&2

    return 0
}


################################################################################
# Markdown formatting

markdown_title() {
    local label=$1
    local level=${2:-1}

    for ((i=1; i<=level; i++)); do
        echo -n '#'
    done

    echo " ${label}"
}

markdown_link() {
    local label=$1
    local url=$2

    if [[ -z $url ]]; then
        echo "[$label]"
        return 0
    fi

    echo "[$label]($url)"
}

markdown_list() {
    local content=$1

    local prefix="* ${MD_BOLD}"
    local suffix="${MD_BOLD}${MD_BR}"

    echo "$content" | sed "s/.*/${prefix}&${suffix}/"
}

markdown_indent_list_items() {
    local content=$1

    local list_prefix_pattern
    list_prefix_pattern="$(regex_escape "* ${MD_BOLD}")"

    # indent extended description (not starting with list prefix)
    local indent="  "
    echo "$content" | sed -E \
        -e "/^${list_prefix_pattern}/! s/^(.*)$/${indent}\1${MD_BR}/gm" \
        -e "s/^${indent}${MD_BR}$/${indent}/gm"
}


################################################################################
# Jira functions

jira_check_env() {
    [[ -n $JIRA_USER ]]     || exit_error "$ERR_MR_ENV" "JIRA_USER is not set"
    [[ -n $JIRA_TOKEN ]]    || exit_error "$ERR_MR_ENV" "JIRA_TOKEN is not set"
    [[ -n $JIRA_INSTANCE ]] || exit_error "$ERR_MR_ENV" "JIRA_INSTANCE is not set"
}

jira_request() {
    jira_check_env

    local request_url=$1
    local request_verb=${2:-"GET"}
    local request_data=${3}

    local jira_base_url="https://${JIRA_INSTANCE}/rest/api/3"

    local auth_token; auth_token=$(echo -n "${JIRA_USER}:${JIRA_TOKEN}" | base64 -w 0)

    echo_debug "Jira - ${request_verb} ${request_url} ${request_data}"

    [[ $request_verb != "GET" ]] && git_mr_readonly && return 0

    curl -Ss \
        -X "${request_verb}" \
        -H "Authorization: Basic ${auth_token}" \
        -H "Content-Type: application/json" \
        --data "${request_data}" \
        --max-time "${GIT_MR_TIMEOUT:-5}" \
        "${jira_base_url}/${request_url}" || exit_error "$ERR_JIRA_API" "Jira request error"
}

jira_ticket_data() {
    jira_check_env

    local issue_code=$1;  [[ -n $issue_code ]] || exit_error "$ERR_MR" "issue_code required"

    jira_request "issue/${issue_code}?fields=summary" || exit $?
}

jira_show_transitions() {
    local issue_code=${1:-${GIT_MR_CODE:-$(guess_issue_code "$(git_current_branch)")}}

    echo "Available Jira transitions:"
    jira_request "issue/${issue_code}/transitions" |
        jq -r '.transitions[] | [
            "", .id,
            "\"" + .name + "\"" + (" " * (23 - (.name | length))),
            "-> " + (.to | .name + (" " * (23 - (.name | length)))),
            "[" + .to.statusCategory.name + "]"
        ] | @tsv' |
        sed 's/\r//g'
}

jira_transition() {
    jira_check_env

    local issue_code=$1;     [[ -n $issue_code    ]] || exit_error "$ERR_MR" "issue_code required"
    local transition_id=$2;  [[ -n $transition_id ]] || exit_error "$ERR_MR" "transition_id required"

    local transition;   transition=$(jq_build "id" "$transition_id")        || exit "$ERR_MR"
    local request_data; request_data=$(jq_build "transition" "$transition") || exit "$ERR_MR"

    jira_request "issue/${issue_code}/transitions" "POST" "$request_data" || exit $?
}


################################################################################
# Gitlab functions

gitlab_check_env() {
    [[ -n $GITLAB_DOMAIN ]] || exit_error "$ERR_MR_ENV" "GITLAB_DOMAIN is not set"
    [[ -n $GITLAB_TOKEN ]]  || exit_error "$ERR_MR_ENV" "GITLAB_TOKEN is not set"
}

gitlab_remote() {
    local remote remote_url

    for remote in $(git remote); do
        remote_url=$(git remote get-url --push "$remote" | grep "${GITLAB_DOMAIN}" || true)
        [[ -n "$remote_url" ]] && echo "$remote" && return 0
    done

    return "$ERR_GIT_REPO"
}

gitlab_project_url() {
    local remote
    local remote_url
    local project_url

    remote=$(gitlab_remote)
    [[ -n $remote ]] &&
        remote_url=$(git remote get-url --push "$remote" | grep "${GITLAB_DOMAIN}")

    if [[ "$remote_url" == git* ]]; then
        project_url=$(echo "$remote_url" | sed "s/git\@${GITLAB_DOMAIN}:\(.*\).git/\1/")
    elif [[ "$remote_url" == https* ]]; then
        project_url=$(echo "$remote_url" | sed "s/https:\/\/${GITLAB_DOMAIN}\/\(.*\).git/\1/")
    fi

    if [[ -z $project_url ]]; then
        remote=$(git remote | head -n 1)
        remote_url=$(git remote get-url --push "$remote")

        local suggested_domain
        suggested_domain=$(git remote get-url --push "$remote" | sed 's/.*@\(.*\):.*/\1/')

        exit_error "$ERR_GIT_REPO" "$(cat <<- EOF
			Unable to determine Gitlab project URL, check GITLAB_DOMAIN configuration
			  ${remote}:     ${remote_url}
			  current:    GITLAB_DOMAIN="${GITLAB_DOMAIN}"
			  Suggestion: GITLAB_DOMAIN="${suggested_domain}"
		EOF
        )"
    fi

    echo "$project_url"
}

gitlab_project_request() {
    gitlab_check_env

    local request_url=$1
    local request_verb=${2:-"GET"}
    local request_data=${3}

    local project_url; project_url=$(gitlab_project_url) || exit $?

    gitlab_request "projects/$(urlencode "$project_url")/${request_url}" "$request_verb" "$request_data"
}

gitlab_request() {
    gitlab_check_env

    local request_url=$1
    local request_verb=${2:-"GET"}
    local request_data=${3}

    local gitlab_base_url="https://${GITLAB_DOMAIN}/api/v4"

    echo_debug "GitLab - ${request_verb} ${gitlab_base_url}/${request_url} ${request_data}"

    [[ $request_verb != "GET" ]] && git_mr_readonly && echo '{}' && return 0

    local result
    result=$(curl -Ss \
        -X "${request_verb}" \
        -H "Private-Token: ${GITLAB_TOKEN}" \
        -H "Content-Type: application/json" \
        --data "${request_data}" \
        --max-time "${GIT_MR_TIMEOUT:-5}" \
        "${gitlab_base_url}/${request_url}") || exit_error "$ERR_GITLAB_API" "Gitlab request error"

    [[ -z "$(gitlab_check_error "$result")" ]] || return "$ERR_GITLAB"

    echo "$result"
}

gitlab_check_error() {
    local result=$1

    local hasErrorMessage
    hasErrorMessage=$(echo "$result" | jq 'if type=="object" then (has("error") or has("message")) else false end')

    if [[ $hasErrorMessage == 'true' ]]; then
        echo_error "\nGitlab error:\n  ${result}"

        echo "ko"
    fi
}

gitlab_new_merge_request_url() {
    gitlab_check_env

    local project_url; project_url=$(gitlab_project_url) || exit $?

    local source_branch=${1:-$(git_current_branch)}
    if ! git_remote_branch_exists "$source_branch"; then
        echo_error "Branch '$source_branch' does not exist on remote"
        return "$ERR_GITLAB"
    fi

    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}
    if ! git_remote_branch_exists "$target_branch"; then
        echo_error "Target branch '$target_branch' does not exist on remote"
        return "$ERR_GITLAB"
    fi

    local gitlab_mr_url="https://${GITLAB_DOMAIN}/${project_url}/-/merge_requests/new"

    gitlab_mr_url="${gitlab_mr_url}?$(urlencode "merge_request[source_branch]")=${source_branch}"
    gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[target_branch]")=${target_branch}"

    # default labels
    for label_id in $(gitlab_default_label_ids); do
        gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[label_ids][]")=${label_id}"
    done

    # other options
    if [[ "${GITLAB_DEFAULT_FORCE_REMOVE_SOURCE_BRANCH:-1}" -eq 1 ]]; then
        gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[force_remove_source_branch]")=1"
    fi

    # title
    local title
    title=$(git_titlize_branch "$source_branch")
    title=$(gitlab_title_to_draft "$title")
    title=$(urlencode "$title")
    gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[title]")=${title}"

    echo "$gitlab_mr_url"
}

gitlab_merge_request_summary() {
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    local result
    result=$(gitlab_project_request "merge_requests?state=opened&view=simple&source_branch=${source_branch}") || exit $?

    [[ -n $result && $result != "[]" ]] || return "$ERR_GITLAB"

    echo "$result" | jq '.[0]'
}

gitlab_merge_requests_search() {
    gitlab_check_env

    local search_term=$1;  [[ -n $search_term ]] || exit_error "$ERR_MR" "search_term required"

    local result
    result=$(gitlab_request "merge_requests?scope=all&state=all&view=simple&search=$(urlencode "$search_term")&in=title&order_by=created_at&sort=asc") || exit $?
    [[ -n $result && $result != "[]" ]] || return "$ERR_GITLAB"

    result=$(echo "$result" | jq -c 'map(select(.state != "closed") | {iid: .iid, title: .title, web_url: .web_url, state: .state, project_id: .project_id}) | .[]')
    [[ -n $result && $result != "[]" ]] || return "$ERR_GITLAB"

    echo "$result"
}

gitlab_projects() {
    local result

    result=$(gitlab_request "projects?simple=true&archived=false&order_by=last_activity_at&per_page=100") || exit $?
    [[ -n $result && $result != "[]" ]] || return "$ERR_GITLAB"

    result=$(echo "$result" | jq 'map({id: .id, name: .name, path_with_namespace: .path_with_namespace})')
    [[ -n $result && $result != "[]" ]] || return "$ERR_GITLAB"

    echo "$result"
}

gitlab_merge_request() {
    gitlab_check_env

    local mr_iid=$1;  [[ -n $mr_iid ]] || exit_error "$ERR_MR" "No mr_iid provided"

    gitlab_project_request "merge_requests/$mr_iid"
}

gitlab_extract_iid() {
    local mr_summary=$1
    echo "$mr_summary" | jq -r '.iid'
}

gitlab_extract_url() {
    local mr_summary=$1
    echo "$mr_summary" | jq -r '.web_url'
}

gitlab_extract_title() {
    local mr_detail=$1
    echo "$mr_detail" | jq -r '.title'
}

gitlab_extract_description() {
    local mr_detail=$1
    echo "$mr_detail" | jq -r '.description'
}

gitlab_extract_merge_status() {
    local mr_detail=$1

    if [[ "$(echo "$mr_detail" | jq -r '.state')" == "merged" ]]; then
        echo "merged"
        return 0
    fi

    echo "$mr_detail" | jq -r '.merge_status'
}

gitlab_extract_pipeline_status() {
    local mr_detail=$1

    echo "$mr_detail" | jq -r '.head_pipeline.status'
}

gitlab_extract_pipeline_url() {
    local mr_detail=$1

    echo "$mr_detail" | jq -r '.head_pipeline.web_url'
}

gitlab_extract_target_branch() {
    local mr_detail=$1
    echo "$mr_detail" | jq -r '.target_branch'
}

gitlab_extract_labels() {
    local mr_detail=$1
    echo "$mr_detail" | jq -r '.labels | join(",")'
}

gitlab_extract_project_url() {
    local mr_url=$1

    local project_url
    project_url=$(echo "$mr_url" |
        sed "s/https:\/\/$GITLAB_DOMAIN\///" | # remove prefix
        sed "s/\/-\/merge_requests\/[0-9]*\$//") # remove suffix

    project_url=$(urlencode "$project_url")

    echo "$project_url"
}

gitlab_merge_request_threads() {
    gitlab_check_env

    local project_url=$1
    local mr_iid=$2

    [[ -n $project_url ]] || exit_error "$ERR_MR" "No project_url provided"
    [[ -n $mr_iid ]]      || exit_error "$ERR_MR" "No mr_iid provided"

    local thread_summaries
    local per_page=100
    local page=1
    local notes_page_count=${per_page}

    while [[ $notes_page_count -eq "$per_page" ]]; do

        # fetch page
        local notes_page
        notes_page=$(gitlab_request "projects/${project_url}/merge_requests/$mr_iid/discussions?per_page=${per_page}&page=${page}")

        if [[ $notes_page != "[]" ]]; then

            local thread_summaries_page
            thread_summaries_page=$(echo "$notes_page" | jq -r '
                map(
                    select(any(.notes[]; .resolvable == true)) |
                    {
                        id: .id,
                        unresolved: any(.notes[]; .resolvable == true and .resolved == false),
                        first_unresolved_note_id: .notes | map(select(.resolvable == true and .resolved == false) | .id) | .[0]
                    }
                ) | .[] |
                .id + "\t" + "unresolved:" + (.unresolved | tostring) + "\t" + "note_id:" + (.first_unresolved_note_id | tostring)' |
                sed 's/\r//g')

            # append page
            if [[ -z $thread_summaries ]]; then
                thread_summaries="$thread_summaries_page"
            else
                thread_summaries=$(echo -e "${thread_summaries}\n${thread_summaries_page}")
            fi

            # increment
            notes_page_count=$(echo "$notes_page" | jq -r 'length')
            page=$((page + 1))
        else
            notes_page_count=0
        fi
    done

    echo "$thread_summaries"
}

gitlab_default_label_ids() {
    gitlab_check_env

    local gitlab_labels; gitlab_labels=$(gitlab_project_request "labels")

    # split in multiple lines
    gitlab_labels=$(echo "$gitlab_labels" | sed "s/},/},\n/g")

    # extact ids
    local default_labels oIFS
    oIFS="$IFS"; IFS=','; read -ra default_labels <<<"$GITLAB_DEFAULT_LABELS"; IFS="$oIFS"; unset oIFS
    for label in "${default_labels[@]}"; do
        local label_id; label_id=$(echo "$gitlab_labels" | jq -r '.[] | select(.name == "'"$label"'") | .id')
        [[ -n $label_id ]] &&
            echo "$label_id"
    done
}

gitlab_merge_request_update() {
    gitlab_check_env

    local mr_iid=$1;   [[ -n $mr_iid ]]  || exit_error "$ERR_MR" "No mr_iid provided"
    local mr_data=$2;  [[ -n $mr_data ]] || exit_error "$ERR_MR" "No data provided"

    gitlab_project_request "merge_requests/${mr_iid}" "PUT" "${mr_data}"
}

gitlab_merge_request_merge() {
    gitlab_check_env

    local mr_iid=$1;  [[ -n $mr_iid ]] || exit_error "$ERR_MR" "No mr_iid provided"

    gitlab_project_request "merge_requests/${mr_iid}/merge?should_remove_source_branch=${GITLAB_DEFAULT_FORCE_REMOVE_SOURCE_BRANCH:-1}" "PUT"
}

gitlab_title_is_draft() {
    local title=$1
    for prefix in "${GITLAB_DRAFT_PREFIXES[@]}"; do
        if echo "$title" | grep -q "^${prefix}:"; then
            return 0
        fi
    done
    return 1
}

gitlab_title_to_draft() {
    local title=$1
    echo "${GITLAB_DRAFT_PREFIX}: $title"
}

gitlab_title_undraft() {
    local title=$1
    for prefix in "${GITLAB_DRAFT_PREFIXES[@]}"; do
        title=$(echo "$title" | sed "s/^${prefix}:\s*//g")
    done
    echo "$title"
}

gitlab_undraft() {
    git_mr_readonly show
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    # Search existing merge request
    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"
        mr_print "$source_branch"
        return "$ERR_GITLAB"
    fi

    local mr_iid; mr_iid=$(gitlab_extract_iid "$mr_summary")
    local mr_title; mr_title=$(gitlab_extract_title "$mr_summary")

    # Print merge request status summary
    echo
    mr_status_block "$mr_iid"
    echo "--------------------------------------------------------------------------------"
    echo

    if ! gitlab_title_is_draft "$mr_title"; then
        echo_error "Merge request is not a draft"
        echo_error
        return 0
    fi

    local undraft_title; undraft_title=$(gitlab_title_undraft "$mr_title")

    if confirm "Do you want to resolve draft status?"; then
        echo -n "Resolving draft status... "

        local mr_data; mr_data=$(jq_build "title" "$undraft_title") || exit "$ERR_MR"

        local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_data")
        [[ -n $result ]] && echo -e "OK\n"
    fi
}


################################################################################
# Merge request utility functions

guess_issue_code() {
    [[ -z $git_mr_unguessable_issue_code ]] || return
    [[ -n $JIRA_CODE_PATTERN ]] || { echo_error "JIRA_CODE_PATTERN not set - unable to guess issue code"; return "$ERR_MR_ENV"; }

    local branch=${1:-$(git_current_branch)}

    local issue_code; issue_code=$(echo "${branch}" |
        grep -Eo "$JIRA_CODE_PATTERN" |
        tail -n1)

    if [[ -z $issue_code ]]; then
        echo_error "Unable to guess issue code"
        return 1
    fi

    echo_debug "Issue code: $issue_code"

    echo "$issue_code"
}

mr_title() {
    local source_branch=${1:-$(git_current_branch)}
    local issue_code=${2:-${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}}

    if [[ -z $issue_code ]]; then
        git_titlize_branch "$source_branch"
        return 0
    fi

    local issue_content; issue_content=$(jira_ticket_data "$issue_code")

    local issue_key;     issue_key=$(echo "$issue_content" | jq -r '.key // empty')
    local issue_title;   issue_title=$(echo "$issue_content" | jq -r '.fields.summary // empty')

    [[ -z $issue_key ]] &&
        issue_key=${issue_code^^}

    if [[ -z $issue_title ]]; then
        echo_error "Unable to get issue title from Jira"
        echo_error "  issue_code: $issue_code"
        [[ -n $issue_content ]] &&
            echo_error "  $issue_content"

        echo "$issue_key"
        return 0
    fi

    local issue_url="https://${JIRA_INSTANCE}/browse/${issue_key}"

    markdown_link "${issue_key} ${issue_title}" "$issue_url"
}

mr_commit_list() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}

    if [[ $GIT_MR_EXTENDED -eq 1 ]]; then
        markdown_indent_list_items "$(git_commits_extended "$source_branch" "$target_branch")"
    else
        markdown_list "$(git_commits "$source_branch" "$target_branch")"
    fi
}

mr_description() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}
    local issue_code=${3:-${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}}

    local title; title=$(mr_title "$source_branch" "$issue_code")

    mr_print_description "$title" "$(mr_commit_list "$source_branch" "$target_branch")"
}

mr_print_description() {
    local title=$1
    local commit_list=$2

    cat <<EOF
$(markdown_title "$title")


## Commits

${commit_list}

EOF
}

mr_status_block() {
    local mr_iid=$1
    local merge_request; merge_request=${2:-$(gitlab_merge_request "$mr_iid")}

    local mr_title=${3:-$(gitlab_extract_title "$merge_request")}
    local mr_url=${4:-$(gitlab_extract_url "$merge_request")}

    local mr_threads=$5
    if [[ -z $mr_threads ]]; then
        local mr_url; mr_url=$(gitlab_extract_url "$merge_request")
        local project_url; project_url=$(gitlab_extract_project_url "$mr_url")
        mr_threads=$(gitlab_merge_request_threads "$project_url" "$mr_iid")
    fi

    mr_print_title "$mr_title" "$mr_url"
    mr_print_status "$merge_request" "$mr_threads"
}

mr_print_title() {
    local mr_title=$1
    local mr_url=$2

    echo "--------------------------------------------------------------------------------"
    echo " $(terminal_link "$mr_url" "$(gitlab_title_undraft "$mr_title")")"
    has_links || echo " ⇒ $mr_url"
    echo "--------------------------------------------------------------------------------"
}

mr_show_status() {
    local mr_iid=$1

    local merge_request; merge_request=${2:-$(gitlab_merge_request "$mr_iid")}

    local mr_threads=$3
    if [[ -z $mr_threads ]]; then
        local mr_url; mr_url=$(gitlab_extract_url "$merge_request")
        local project_url; project_url=$(gitlab_extract_project_url "$mr_url")
        mr_threads=$(gitlab_merge_request_threads "$project_url" "$mr_iid")
    fi

    mr_print_status "$merge_request" "$mr_threads"
}

mr_print_status() {
    local merge_request=$1
    local threads=$2

    [[ -n $merge_request ]] || exit_error "$ERR_MR" "merge_request not provided"

    local mr_url;      mr_url=$(gitlab_extract_url "$merge_request")
    local project_url; project_url=$(gitlab_extract_project_url "$mr_url")

    # Labels
    local labels; labels=$(gitlab_extract_labels "$merge_request")
    local labels_display; labels_display=$(mr_format_labels "$labels")

    local labels_count; labels_count=$(echo "$labels" | sed 's/[^,]//g' | wc -m)
    local labels_str_len=$((${#labels} + $((labels_count * 2)) + 4)) # 2 spaces + 2 for larger icon

    # Votes

    local upvotes;   upvotes=$(echo "$merge_request" | jq -r '.upvotes')
    local downvotes; downvotes=$(echo "$merge_request" | jq -r '.downvotes')

    if [[ $upvotes -gt 1 ]];   then upvotes=$(colorize "$upvotes" "bold" "lightgreen")
    elif [[ $upvotes -gt 0 ]]; then upvotes=$(colorize "$upvotes" "bold" "lightyellow")
                               else upvotes=$(colorize "$upvotes" "bold"); fi

    if [[ $downvotes -gt 0 ]];
        then downvotes=$(colorize "$downvotes" "bold" "lightred")
        else downvotes=$(colorize "$downvotes" "bold"); fi

    # Threads
    local thread_count;   thread_count="$(echo "$threads" | grep -c 'unresolved:' || true)"
    local resolved_count; resolved_count="$(echo "$threads" | grep -c 'unresolved:false' || true)"

    local thread_count_display
        thread_count_display=$(colorize "$thread_count" "bold")

    local resolved_count_display; if [[ $resolved_count -lt "$thread_count" ]];
        then resolved_count_display=$(colorize "$resolved_count" "bold" "lightred")
        else resolved_count_display=$(colorize "$resolved_count" "bold" "lightgreen"); fi

    local threads_display="${resolved_count_display}/${thread_count_display}"

    if [[ $resolved_count -lt "$thread_count" ]]; then
        local first_unresolved_note_id
        first_unresolved_note_id=$(echo "$threads" | grep 'unresolved:true' | cut -f 3 | cut -d ':' -f 2 | head -n 1)
        local note_url="${mr_url}#note_${first_unresolved_note_id}"
        threads_display=$(terminal_link "$note_url" "$threads_display")
    fi

    # Title
    local title; title=$(gitlab_extract_title "$merge_request")

    # Merge status
    local merge_status; merge_status=$(gitlab_extract_merge_status "$merge_request")
    local merge_status_icon; if [[ $merge_status == "merged" || $merge_status == "can_be_merged" ]];
        then merge_status_icon="$(colorize "\U00002714" "lightgreen" "bold")"; # heavy check mark
        else merge_status_icon="$(colorize "\U0000274C" "lightred" "bold")"; fi # cross mark

    # Pipeline status
    local pipeline_status; pipeline_status="$(gitlab_extract_pipeline_status "$merge_request")"
    local pipeline_url; pipeline_url="$(gitlab_extract_pipeline_url "$merge_request")"
    local pipeline_icon
    case "$pipeline_status" in
        created|waiting_for_resource|preparing|pending|running)
                          pipeline_icon="$(colorize "⏱" "lightgray")" ;;
        success)          pipeline_icon="$(colorize "✔" "lightgreen" "bold")" ;;
        failed)           pipeline_icon="$(colorize "❌" "lightred" "bold")" ;;
        canceled|skipped) pipeline_icon="$(colorize "➖" "lightgray")" ;;
        manual)           pipeline_icon="$(colorize "🔧" "lightgray")" ;;
        scheduled)        pipeline_icon="$(colorize "⏰" "lightgray")" ;;
        null)             pipeline_icon= ;;
        *)                pipeline_icon="$(colorize "?" "lightgray")" ;;
    esac
    local ci_str=
    [[ -n $pipeline_icon ]] &&
        ci_str="CI: $pipeline_icon"

    # Merge target
    local current_target; current_target=$(gitlab_extract_target_branch "$merge_request")

    local target_display
    target_display="${target_display}$(colorize "(\U000021A3 " "gray")"
    target_display="${target_display}$(colorize "$current_target" "lightpurple")"
    target_display="${target_display}$(colorize ")" "gray")"

    local target_str_len=$((${#current_target} + 4))

    # Draft status
    local draft_str=
    local draft_str_len=0
    if gitlab_title_is_draft "$title"; then
        draft_str="🚧 Draft"
        draft_str_len=12 # 7 chars + 4 spaces + 1 for larger icon
    fi

    # Spacers for CI & target branch indicators
    # Spacers for draft & target branch indicators
    local display_width=76 # not counting 3 leading spaces
    local spacer_chars=$((display_width - labels_str_len - target_str_len - draft_str_len))
    local spacer_chars_l=0
    local spacer_chars_r=0

    if [[ $spacer_chars -gt 0 ]]; then
        spacer_chars_l=$((43 - labels_str_len)) # 42: roughly at the same level as CI indicator
        spacer_chars_r=$((spacer_chars - spacer_chars_l))
        if [[ $spacer_chars_r -lt 0 ]]; then
            spacer_chars_l=$((spacer_chars_l + spacer_chars_r))
            spacer_chars_r=0
        fi
    fi

    # Display
    echo

    # 1st row ------------------------------------------------------------------
    # Labels
    echo -en "   \U0001F3F7  ${labels_display}"
    echo_spacer "$spacer_chars_l"
    # Draft status
    if [[ -n $draft_str ]]; then
        echo -en "  $(colorize "$draft_str" "orange")  "
    else
        echo_spacer $((2 - spacer_chars_l - spacer_chars_r))
    fi
    echo_spacer "$spacer_chars_r"
    # Target
    echo -e "${target_display}\n"

    # 2nd row ------------------------------------------------------------------
    # Votes
    echo -en "   \U0001F44D  ${upvotes}"
    echo -en "   \U0001F44E  ${downvotes}"
    # Threads
    if [[ $thread_count -gt 0 ]]; then
        echo -n "     Resolved threads: ${threads_display}"
    else
        echo -n "                          "
    fi
    # Pipeline
    if [[ -n $ci_str ]]; then
        echo -en "      $(terminal_link "$pipeline_url" "$ci_str")  "
    else
        echo -n "             "
    fi
    # Merge status
    if [[ $merge_status != "merged" ]]; then
        echo -en "     Can be merged: ${merge_status_icon}"
    else
        echo -en "            $(colorize "Merged" "lightgreen")"
    fi
    echo -e "\n"
}


################################################################################
# Merge request labels utility functions

replace_labels() {
    local labels=$1
    local to_remove=$2
    local to_add=$3

    # split
    labels=$(    echo "$labels"    | tr "," "\n")
    to_remove=$( echo "$to_remove" | tr "," "\n")
    to_add=$(    echo "$to_add"    | tr "," "\n")

    # remove
    [[ -n $to_remove ]] && labels=$(echo "$labels" | grep -v "$to_remove")
    [[ -n $to_add ]]    && labels=$(echo "$labels" | grep -v "$to_add")

    # add
    [[ -n $to_add ]] && labels=$(echo -e "${labels}\n${to_add}")

    # implode
    labels=$(echo "$labels" | tr "\n" "," | sed 's/^,//' | sed 's/,$//')

    echo "$labels"
}

labels_differ() {
    local old_labels=$1
    local new_labels=$2

    [[ $old_labels == "$new_labels" ]] && return 1

    local old_sorted; old_sorted=$(echo "$old_labels" | tr "," "\n" | grep . | sort -u | tr "\n" ",")
    local new_sorted; new_sorted=$(echo "$new_labels" | tr "," "\n" | grep . | sort -u | tr "\n" ",")

    [[ $old_sorted == "$new_sorted" ]] && return 1

    return 0
}

is_status_label() {
    local label=$1

    local status_labels=${2:-"${GITLAB_IP_LABELS},${GITLAB_OK_LABELS},${GITLAB_CR_LABELS},${GITLAB_QA_LABELS}"}
    status_labels=$(echo "$status_labels" |
        sed 's/,,/,/g' |
        sed 's/^,//' | sed 's/,$//' |
        tr "," "\n")

    local match
    match="$( echo "$label" | grep "$status_labels")" || return 1

    # reverse-match is important, we don't want "Jean-Pierre BACRI Team" to match "CR" label
    (echo "$status_labels" | grep "$match" > /dev/null) || return 1

    echo "$match"
}

is_status_ip_label() {
    is_status_label "$1" "$GITLAB_IP_LABELS"
}

is_status_cr_label() {
    is_status_label "$1" "$GITLAB_CR_LABELS"
}

is_status_qa_label() {
    is_status_label "$1" "$GITLAB_QA_LABELS"
}

is_status_ok_label() {
    is_status_label "$1" "$GITLAB_OK_LABELS"
}

mr_format_labels() {
    local labels=$1

    local labels_array; IFS=',' read -ra labels_array <<<"$labels"

    local status_labels=()
    local other_labels=()

    for label in "${labels_array[@]}"; do
        if [[ -n "$(is_status_ip_label "$label")" ]]; then
            # shellcheck disable=SC2086 # Allow splitting of terminal color
            status_labels+=("$(colorize "[$label]" ${GIT_MR_STATUS_IP_LABEL_COLOR:-orange})")
        elif [[ -n "$(is_status_cr_label "$label")" ]]; then
            # shellcheck disable=SC2086 # Allow splitting of terminal color
            status_labels+=("$(colorize "[$label]" ${GIT_MR_STATUS_CR_LABEL_COLOR:-lightblue bold})")
        elif [[ -n "$(is_status_qa_label "$label")" ]]; then
            # shellcheck disable=SC2086 # Allow splitting of terminal color
            status_labels+=("$(colorize "[$label]" ${GIT_MR_STATUS_QA_LABEL_COLOR:-lightpurple bold})")
        elif [[ -n "$(is_status_ok_label "$label")" ]]; then
            # shellcheck disable=SC2086 # Allow splitting of terminal color
            status_labels+=("$(colorize "[$label]" ${GIT_MR_STATUS_OK_LABEL_COLOR:-lightgreen})")
        else
            other_labels+=("[$label]")
        fi
    done

    local status_labels_str; status_labels_str="$(printf "%s " "${status_labels[@]}")"
    local other_labels_str;  other_labels_str="$(printf "%s " "${other_labels[@]}")"

    echo "${status_labels_str}${other_labels_str}" |
        sed 's/^\s*//' | sed 's/\s*$//' # remove leading and trailing spaces
}


################################################################################
# Merge request transition utility functions

mr_update_labels() {
    local mr_iid=$1
    local labels=$2

    # strip leading & trailing label commas
    local to_remove; to_remove=$(echo -e "$3" | sed 's/^,*//' | sed 's/,*$//')
    local to_add;    to_add=$(echo -e "$4" | sed 's/^,*//' | sed 's/,*$//')

    if [[ -z $to_remove && -z $to_add ]]; then
        echo_error "No label to add or remove"
        return 0
    fi

    local new_labels; new_labels=$(replace_labels "$labels" "$to_remove" "$to_add")
    if labels_differ "$labels" "$new_labels" &&
       confirm "Do you want to update the merge request labels to \"$new_labels\"?"; then
        echo -n "Updating merge request labels... "

        local mr_data; mr_data=$(jq_build "labels" "$new_labels") || exit "$ERR_MR"
        local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_data")

        [[ -n $result ]] && echo -e "OK\n"
    fi
}

mr_gitlab_undraft() {
    local mr_iid=$1
    local mr_summary=$2

    local mr_title; mr_title=$(gitlab_extract_title "$mr_summary")

    gitlab_title_is_draft "$mr_title" || return 0

    confirm "Do you want to resolve draft status?" || return 0

    echo -n "Resolving draft status... "

    local undraft_title; undraft_title=$(gitlab_title_undraft "$mr_title")
    local mr_data; mr_data=$(jq_build "title" "$undraft_title") || exit "$ERR_MR"

    local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_data")
    [[ -n $result ]] && echo -e "OK\n"
}

mr_jira_transition() {
    local issue_code=$1
    local jira_target_status=$2
    local jira_transition_id_var=$3

    local jira_transition_id=${!jira_transition_id_var}

    [[ -n $issue_code ]] || return 0

    confirm "Do you want to update the Jira ticket status to \"${jira_target_status}\"?" || return 0

    if [[ -z $jira_transition_id ]]; then
        echo_error "Set ${jira_transition_id_var} to be able to update Jira status."
        jira_show_transitions "$issue_code"
        return 0
    fi

    echo -n "Updating Jira ticket status... "
    jira_transition "$issue_code" "$jira_transition_id" && echo -e "OK\n"
}


################################################################################
# Merge request menu utility functions

mr_menu_merge_requests() {
    local issue_code=${1:-${GIT_MR_CODE:-$(guess_issue_code)}}

    local mr_summaries; mr_summaries=$(gitlab_merge_requests_search "$issue_code") || exit $?
    [[ -n $mr_summaries ]] || return "$ERR_GITLAB"

    # Load project names into bash associative array
    declare -A project_arr
    local id name
    while IFS="=" read -r id name; do
        project_arr[$id]="$name"
    done < <(gitlab_projects | jq -r 'map((.id | tostring)+"="+.name) | .[]' | sed 's/\r//g')

    # Enrich merge request summaries with project names
    while IFS=$'\n' read -r mr_summary; do
        local project_id; project_id=$(echo "$mr_summary" | jq -r '.project_id')
        local project_name; project_name=${project_arr[$project_id]}

        echo "$mr_summary" | jq -c --arg project_name "$project_name" '. + {project_name: $project_name}'
    done < <(echo "$mr_summaries")
}

mr_menu_contents() {
    local menu_items=$1
    local current_mr_url=$2

    echo "$GIT_MR_MENU_START"
    echo

    while IFS=$'\n' read -r menu_item; do
        local project_name; project_name=$(echo "$menu_item" | jq -r '.project_name')
        local title;        title=$(echo "$menu_item" | jq -r '.title')
        local web_url;      web_url=$(echo "$menu_item" | jq -r '.web_url')

        title=$(gitlab_title_undraft "$title")

        local item_label; item_label="${project_name}: $(markdown_link "${title}" "$web_url")"

        local wrap=''
        [[ $current_mr_url == "$web_url" ]] &&
            wrap='**' # Markdown bold

        echo "* ${wrap}${item_label}${wrap}"
    done < <(echo "$menu_items")

    echo
    echo "$GIT_MR_MENU_END"
}

mr_menu_print_title() {
    local issue_code=$1
    local menu_items=$2
    local current_index=$3

    local search_url; search_url="https://${GITLAB_DOMAIN}/dashboard/merge_requests?scope=all&state=all&search=$(urlencode "$issue_code")&in=title&sort=created_asc"
    local mr_count; mr_count=$(echo "$menu_items" | wc -l | tr -d ' ')

    echo "================================================================================"
    [[ -z $current_index ]] &&
        echo " $(terminal_link "$search_url" "$issue_code") (${mr_count} merge request$([[ $mr_count -gt 1 ]] && echo 's'))" ||
        echo " $(terminal_link "$search_url" "$issue_code") (merge request ${current_index}/${mr_count})"
    echo "================================================================================"
}

mr_menu_status() {
    local issue_code=$1
    local menu_items=$2

    echo
    mr_menu_print_title "$issue_code" "$menu_items"
    echo

    while IFS=$'\n' read -r menu_item; do
        local mr_iid;       mr_iid=$(echo "$menu_item" | jq -r '.iid')
        local project_name; project_name=$(echo "$menu_item" | jq -r '.project_name')
        local title;        title=$(echo "$menu_item" | jq -r '.title')
        local web_url;      web_url=$(echo "$menu_item" | jq -r '.web_url')

        title=$(gitlab_title_undraft "$title")
        local project_url; project_url=$(gitlab_extract_project_url "$web_url")

        # Load existing merge request details
        # Do NOT use `gitlab_merge_request`
        local merge_request; merge_request=$(gitlab_request "projects/${project_url}/merge_requests/$mr_iid")

        echo "* $(colorize "$project_name" "bold"): $(terminal_link "$web_url" "$title")"
        has_links || echo "  ⇒ $web_url"
        mr_show_status "$mr_iid" "$merge_request"
        echo
    done < <(echo "$menu_items")
}

mr_menu_show() {
    local issue_code=$1
    local menu_items=$2

    echo
    mr_menu_print_title "$issue_code" "$menu_items"
    echo

    mr_menu_contents "$menu_items"
}

mr_menu_update() {
    git_mr_readonly show

    local menu_items=$1

    local current_branch; current_branch=$(git_current_branch)

    # Search existing merge request
    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$current_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"
        echo
        mr_menu_contents "$menu_items"
        return "$ERR_GITLAB"
    fi

    local mr_iid; mr_iid=$(gitlab_extract_iid "$mr_summary")
    local mr_url; mr_url=$(gitlab_extract_url "$mr_summary")

    # Load existing merge request details
    local merge_request;  merge_request=$(gitlab_merge_request "$mr_iid")
    local mr_description; mr_description=$(gitlab_extract_description "$merge_request")
    local mr_title;       mr_title=$(gitlab_extract_title "$merge_request")

    local mr_menu_content; mr_menu_content=$(mr_menu_contents "$menu_items" "$mr_url")
    local updated_description; updated_description="$(mr_menu_replace_description "$mr_description" "$mr_menu_content")"

    mr_menu_print_description "$updated_description" "$mr_url" "$mr_title"

    local mr_update_data='{}'
    if confirm "Do you want to update the menu in the merge request description?"; then
        mr_update_data=$(jq_build "description" "$updated_description" "$mr_update_data") || exit "$ERR_MR"
    fi
    if [[ $mr_update_data != "{}" ]]; then
        echo -n "Updating merge request..."
        local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_update_data")
        [[ -n $result ]] && echo -e "OK\n"
    fi
}

mr_menu_update_all() {
    git_mr_readonly show

    local issue_code=$1
    local menu_items=$2

    local mr_iid
    local mr_title
    local mr_url
    local project_name
    local project_url
    local merge_request
    local mr_description
    local mr_menu_content
    local updated_description
    local mr_update_data
    local result

    # Use array instead of looping over variable content with `read` to leave standard input open for `confirm`
    local menu_array
    readarray menu_array < <(echo "$menu_items")

    local i=1 updated_count=0
    for menu_item in "${menu_array[@]}"; do

        mr_iid=$(echo "$menu_item" | jq -r '.iid')
        mr_url=$(echo "$menu_item" | jq -r '.web_url')
        mr_title=$(echo "$menu_item" | jq -r '.title')
        project_name=$(echo "$menu_item" | jq -r '.project_name')

        # Beware, `gitlab_merge_request` and `gitlab_merge_request_update` use 'gitlab_project_request', which is project-specific
        # Here, we can expect other target projects here.
        project_url=$(gitlab_extract_project_url "$mr_url")

        # Load existing merge request details
        # Do NOT use `gitlab_merge_request`
        merge_request=$(gitlab_request "projects/${project_url}/merge_requests/$mr_iid")

        mr_description=$(gitlab_extract_description "$merge_request")

        mr_menu_content=$(mr_menu_contents "$menu_items" "$mr_url")
        updated_description="$(mr_menu_replace_description "$mr_description" "$mr_menu_content")"

        clear_screen
        mr_menu_print_title "$issue_code" "$menu_items" "$i"
        mr_menu_print_description "$updated_description" "$mr_url" "$mr_title" "$project_name"

        mr_update_data='{}'
        if confirm "Do you want to update the menu in the merge request description?"; then
            mr_update_data=$(jq_build "description" "$updated_description" "$mr_update_data") || exit "$ERR_MR"
        fi
        if [[ $mr_update_data != "{}" ]]; then
            echo -n "Updating merge request..."
            # Do NOT use `gitlab_merge_request_update`
            result=$(gitlab_request "projects/${project_url}/merge_requests/${mr_iid}" "PUT" "${mr_update_data}")
            [[ -n $result ]] &&
                ((updated_count += 1)) &&
                echo -e "OK\n"
        else
            echo
        fi
        ((i += 1))
    done

    [[ $updated_count -gt 0 ]] &&
        echo "${updated_count} merge request$([[ $updated_count -gt 1 ]] && echo 's') updated"
}

mr_menu_start_line() {
    local mr_description=$1

    echo "$mr_description" | grep -n "$GIT_MR_MENU_START" | head -n1 | cut -d: -f1
}

mr_menu_end_line() {
    local mr_description=$1
    local menu_start=${2:-1}

    local menu_end
    menu_end=$(echo "$mr_description" | tail -n +"$((menu_start + 1))" | grep -n -- "$GIT_MR_MENU_END" | cut -d: -f1 | head -n 1)

    echo $((menu_start + menu_end))
}

mr_menu_replace_description() {
    local mr_description=$1
    local menu_content=$2

    local menu_start; menu_start=$(mr_menu_start_line "$mr_description")
    local menu_end; menu_end=$(mr_menu_end_line "$mr_description" "$menu_start")

    local has_menu=0
    [[ -n $menu_start && -n $menu_end ]] &&
    [[ $menu_start -gt 0 && $menu_end -gt "$menu_start" ]] &&
        has_menu=1

    # Iterate over description lines and insert/replace menu
    local i=1 mr_description_line
    while IFS=$'\n' read -r mr_description_line; do
        if [[ $has_menu -eq 1 ]]; then
            if [[ $i -lt "$menu_start" || $i -gt "$menu_end" ]]; then
                # output non-menu line
                echo "$mr_description_line"
            else
                # replace menu once
                if [[ $i -eq "$menu_end" ]]; then
                    echo_debug "Replacing menu"
                    echo "$menu_content"
                fi
            fi
        else
            # output non-menu line
            echo "$mr_description_line"
            # insert menu once
            if [[ $i -eq "2" ]]; then
                echo_debug "Inserting menu"
                echo "$menu_content"
                echo
            fi
        fi
        ((i += 1))
    done < <(echo "$mr_description")
}

mr_menu_colorize() {
    local mr_description=$1
    local current_mr_url=$2
    local menu_start=$3
    local menu_end=$4

    # Iterate over description lines and colorize menu lines
    local i=1 mr_description_line
    while IFS=$'\n' read -r mr_description_line; do
        if [[ $i -lt "$menu_start" || $i -gt "$menu_end" ]]; then
            # output non-menu line
            echo -e "$(colorize "$mr_description_line" "lightgray")"
        else
            # colorize menu line
            [[ $mr_description_line =~ $current_mr_url ]] &&
                echo -e "$(colorize "$mr_description_line" "bold" "lightyellow")" ||
                echo -e "$(colorize "$mr_description_line" "lightyellow")"
        fi
        ((i += 1))
    done < <(echo "$mr_description")
}

mr_menu_print_description() {
    local mr_description=$1
    local mr_url=$2
    local mr_title=$3
    local project_name=$4

    local menu_start; menu_start=$(mr_menu_start_line "$mr_description")
    local menu_end; menu_end=$(mr_menu_end_line "$mr_description" "$menu_start")

    echo
    echo "--------------------------------------------------------------------------------"
    echo -n " "
    [[ -n $project_name ]] && echo -n "$(colorize "$project_name" "bold"): "
    echo "$(terminal_link "$mr_url" "$(gitlab_title_undraft "$mr_title")")"
    echo "--------------------------------------------------------------------------------"
    echo

    mr_menu_colorize "$mr_description" "$mr_url" "$menu_start" "$menu_end" |
        head -n$((menu_end + GIT_MR_MENU_UPDATE_CONTEXT_LINES)) # truncate description after menu

    local desc_len; desc_len=$(echo "$mr_description" | wc -l)
    if [[ $((desc_len - menu_end)) -gt $GIT_MR_MENU_UPDATE_CONTEXT_LINES ]]; then
        echo
        echo "[...]"
    fi

    echo
    echo "--------------------------------------------------------------------------------"
}


################################################################################
# Merge request top-level functions

mr_print() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}
    git_check_branches "$source_branch" "$target_branch"

    local issue_code=${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}
    [[ -n $issue_code ]] || git_mr_unguessable_issue_code=1

    cat <<EOF

--------------------------------------------------------------------------------
$(mr_description "$source_branch" "$target_branch" "$issue_code")

EOF

    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -n $mr_summary ]]; then
        # Print merge request status summary
        mr_status_block "$(gitlab_extract_iid "$mr_summary")"
    else
        echo "--------------------------------------------------------------------------------"
        echo

        local new_mr_url; new_mr_url=$(gitlab_new_merge_request_url "$source_branch" "$target_branch")
        [[ -n $new_mr_url ]] || return

        cat <<EOF
To create a new merge request:

  ${new_mr_url}

EOF
    fi
}

mr_open() {
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}
    git_check_branches "$source_branch" "$target_branch"

    local issue_code=${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}
    [[ -n $issue_code ]] || git_mr_unguessable_issue_code=1

    local description; description=$(mr_description "$source_branch" "$target_branch" "$issue_code")

    cat <<EOF

--------------------------------------------------------------------------------
$description

EOF

    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -n $mr_summary ]]; then
        open_in_browser "$(gitlab_extract_url "$mr_summary")"

        # Print merge request status summary
        mr_status_block "$(gitlab_extract_iid "$mr_summary")"
    else
        echo "--------------------------------------------------------------------------------"
        echo

        local new_mr_url; new_mr_url=$(gitlab_new_merge_request_url "$source_branch" "$target_branch")
        [[ -n $new_mr_url ]] || return

        # add description
        new_mr_url="${new_mr_url}&$(urlencode "merge_request[description]")=$(urlencode "$description")"

        echo_debug
        echo_debug "Opening:"
        echo_debug "$new_mr_url"

        open_in_browser "$new_mr_url"
    fi
}

mr_status() {
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}
    git_check_branches "$source_branch" "-"

    # Search existing merge request
    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"
        mr_print "$source_branch"
        return "$ERR_GITLAB"
    fi

    local mr_iid; mr_iid=$(gitlab_extract_iid "$mr_summary")
    local mr_url; mr_url=$(gitlab_extract_url "$mr_summary")

    # Load existing merge request details
    local merge_request;  merge_request=$(gitlab_merge_request "$mr_iid")
    local mr_title;       mr_title=$(gitlab_extract_title "$merge_request")
    local current_target; current_target=$(gitlab_extract_target_branch "$merge_request")

    # Print merge request title & status
    echo
    mr_status_block "$mr_iid" "$merge_request"
}

mr_update() {
    git_mr_readonly show
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}

    # Search existing merge request
    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"
        mr_print "$source_branch" "$target_branch"
        return "$ERR_GITLAB"
    fi

    local mr_iid; mr_iid=$(gitlab_extract_iid "$mr_summary")
    local mr_url; mr_url=$(gitlab_extract_url "$mr_summary")

    # Load existing merge request details
    local merge_request;  merge_request=$(gitlab_merge_request "$mr_iid")
    local mr_title;       mr_title=$(gitlab_extract_title "$merge_request")
    local mr_description; mr_description=$(gitlab_extract_description "$merge_request")
    local current_target; current_target=$(gitlab_extract_target_branch "$merge_request")

    # Init commit lists

    local commit_messages; commit_messages=$(git_commits "$source_branch" "$target_branch")

    local current_commits; current_commits=$(echo "$commit_messages" | cut -d ' ' -f1)
    local old_commits;     old_commits=$(echo "$mr_description" |
        grep -Po '^[^0-9a-fA-F]*[0-9a-fA-F]{7,}\s' |
        sed -r 's/^[^0-9a-fA-F]*([0-9a-fA-F]{7,})\s/\1/g')

    local old_commits_array current_commits_array oIFS
    oIFS=$IFS; IFS=$'\n'
        # shellcheck disable=SC2206
        current_commits_array=($current_commits)
        # shellcheck disable=SC2206
        old_commits_array=($old_commits)
    IFS=$oIFS

    local updated_commit_count=0
    local new_commit=
    local new_commit_messages_display=()
    local new_commit_messages_content=()

    local new_description_display="$mr_description"
    local new_description_content="$mr_description"

    local sameColor="lightblue"
    local updatedColor="orange"
    local newColor="green"

    # Iterate over commit lists, compare sha-1 and update description
    for i in ${!current_commits_array[*]}; do

        local curr=${current_commits_array[$i]}
        local old=${old_commits_array[$i]}

        if [[ -n $old ]]; then
            if [[ $old == "$curr" ]]; then
                # same sha-1 - only decorate
                new_description_display=$(echo "$new_description_display" | sed "s/$old/$(colorize "$curr" "$sameColor")/")
                new_description_content=$(echo "$new_description_content" | sed "s/$old/$curr/")
            else
                # different sha-1 - replace & decorate
                new_description_display=$(echo "$new_description_display" | sed "s/$old/$(colorize "$curr" "$updatedColor")/")
                new_description_content=$(echo "$new_description_content" | sed "s/$old/$curr/")
                updated_commit_count=$((updated_commit_count + 1))
            fi
        else
            # new commit
            [[ $GIT_MR_EXTENDED -eq 1 ]] &&
                new_commit="$(git_commit_extended "$curr")" ||
                new_commit="$(echo "$commit_messages" | grep "$curr")"

            new_commit_messages_display+=("$(echo "$new_commit" | sed "s/$curr/$(colorize "$curr" "$newColor")/")")
            new_commit_messages_content+=("$new_commit")
        fi
    done

    local new_commit_count=${#new_commit_messages_display[@]}

    # implode arrays
    local new_commit_messages_display_str; new_commit_messages_display_str=$(printf "%s\n" "${new_commit_messages_display[@]}")
    local new_commit_messages_content_str; new_commit_messages_content_str=$(printf "%s\n" "${new_commit_messages_content[@]}")

    # Print updated merge request description
    echo
    mr_print_title "$mr_title" "$mr_url"
    echo
    echo "$new_description_display"
    if [[ $new_commit_count -gt 0 ]]; then
        if [[ $GIT_MR_UPDATE_NEW_SECTION -eq 1 ]]; then
            echo
            echo "## Update"
            echo
        fi

        if [[ $GIT_MR_EXTENDED -eq 1 ]]; then
            markdown_indent_list_items "$new_commit_messages_display_str"; else
            markdown_list              "$new_commit_messages_display_str"; fi
    fi

    echo
    echo "--------------------------------------------------------------------------------"
    echo
    echo "  updated commits: $(colorize "$updated_commit_count" "$updatedColor")"
    echo "      new commits: $(colorize "$new_commit_count"     "$newColor")"
    echo

    # Propose update if changes are detected

    if [[ ! -x "$(command -v jq)" ]]; then
        echo_error "Please install jq to be able to update merge request"

    else
        local mr_update_data='{}' update_prompt

        if [[ $((updated_commit_count + new_commit_count)) -gt 0 ]]; then
            update_prompt=1
            if confirm "Do you want to update the merge request description?"; then

                local new_description; new_description=$(echo -e "${new_description_content}")
                local newLines=""

                if [[ $new_commit_count -gt 0 ]]; then
                    if [[ $GIT_MR_UPDATE_NEW_SECTION -eq 1 ]]; then
                        new_description=$(echo -e "${new_description}\n\n## Update")
                        newLines="\n"
                    fi
                    [[ $GIT_MR_EXTENDED -eq 1 ]] &&
                        new_description=$(echo -e "${new_description}\n${newLines}$(markdown_indent_list_items "$new_commit_messages_content_str")") ||
                        new_description=$(echo -e "${new_description}\n${newLines}$(markdown_list "$new_commit_messages_content_str")")
                fi
                new_description=$(echo -e "$new_description")$'\n'
                mr_update_data=$(jq_build "description" "$new_description" "$mr_update_data") || exit "$ERR_MR"
            fi
        fi

        if [[ $target_branch != "$current_target" ]]; then
            update_prompt=1
            if confirm "Do you want to update the merge request target branch from '$current_target' to '$target_branch'?"; then
                if git_remote_branch_exists "$target_branch"; then
                    mr_update_data=$(jq_build "target_branch" "$target_branch" "$mr_update_data") || exit "$ERR_MR"
                else
                    echo_error "Target branch '$target_branch' does not exist on remote"
                fi
            fi
        fi

        if [[ $mr_update_data != "{}" ]]; then
            echo -n "Updating merge request..."

            local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_update_data")
            [[ -n $result ]] && echo -e "OK\n"

            # reload merge request details
            merge_request=$(gitlab_merge_request "$mr_iid")
        else
            [[ -n $update_prompt ]] && echo
        fi
    fi

    echo "--------------------------------------------------------------------------------"
    mr_show_status "$mr_iid" "$merge_request"
}

mr_merge() {
    git_mr_readonly show
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    # Search existing merge request
    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"
        mr_print "$source_branch"
        return "$ERR_GITLAB"
    fi

    local mr_iid;      mr_iid=$(gitlab_extract_iid "$mr_summary")
    local mr_title;    mr_title=$(gitlab_extract_title "$mr_summary")
    local mr_url;      mr_url=$(gitlab_extract_url "$mr_summary")
    local project_url; project_url=$(gitlab_extract_project_url "$mr_url")

    # Load existing merge request details
    local merge_request;  merge_request=$(gitlab_merge_request "$mr_iid")
    local merge_status;   merge_status=$(gitlab_extract_merge_status "$merge_request")
    local current_target; current_target=$(gitlab_extract_target_branch "$merge_request")

    # Print merge request status summary
    echo
    mr_status_block "$mr_iid" "$merge_request"
    echo "--------------------------------------------------------------------------------"
    echo

    # test merge status
    if [[ $merge_status == "merged" ]]; then
        echo_error "Merge request is already merged."
        echo_error
        return 0
    fi
    if [[ $merge_status != "can_be_merged" ]]; then
        echo_error "Merge request can not be merged. You probably need to rebase the branch and resolve conflicts."
        echo_error
        return "$ERR_GITLAB"
    fi

    # test open threads
    local unresolved_thread_count
    unresolved_thread_count=$(gitlab_merge_request_threads "$project_url" "$mr_iid" | grep -c 'unresolved:true')

    if [[ $unresolved_thread_count -gt 0 ]]; then
        if [[ $GIT_MR_FORCE -eq 1 ]]; then
            echo_error "There are $unresolved_thread_count unresolved threads. Merging anyway."
            echo_error
        else
            echo_error "There are $unresolved_thread_count unresolved threads. Please resolve them before merging or use the --force option."
            echo_error
            return "$ERR_USER"
        fi
    fi

    if gitlab_title_is_draft "$mr_title"; then
        echo_error "Merge request is a draft (work in progress)"
        confirm "Do you want to resolve draft status?" || { echo_error; return 0; }

        echo -n "Resolving draft status... "
        local undraft_title; undraft_title=$(gitlab_title_undraft "$mr_title")
        local mr_data;       mr_data=$(jq_build "title" "$undraft_title") || exit "$ERR_MR"

        local result; result=$(gitlab_merge_request_update "${mr_iid}" "${mr_data}")
        [[ -n $result ]] && echo -e "OK\n"

        [[ -n $result ]] || { echo_error; return "$ERR_GITLAB"; } # interrupt on error
    fi

    # Merge

    confirm "Do you want to merge '$source_branch' into '$current_target'?" || { echo; return 0; }

    echo -n "Merging '$source_branch'... "
    local result; result=$(gitlab_merge_request_merge "${mr_iid}")
    [[ -n $result ]] && echo -e "OK\n"

    [[ -n $result ]] || { echo_error; return "$ERR_GITLAB"; } # interrupt on error

    # checkout target branch

    confirm "Do you want to checkout '$current_target' and pull changes?" || { echo; return 0; }

    echo "$(colorize "git checkout $current_target && git pull --rebase" "lightgray")"
    git_mr_readonly ||
        (git checkout "$current_target" && git pull --rebase)
    echo

    # delete local branch

    confirm "Do you want to delete local branch '$source_branch'?" || { echo; return 0; }

    echo "$(colorize "git branch -d $source_branch" "lightgray")"
    git_mr_readonly ||
        git branch -d "$source_branch"
    echo
}

mr_menu() {
    gitlab_check_env

    local git_mr_menu_mode=show
    local git_mr_menu_update_all=0

    # Parse options
    args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
        # Consume options
        up|update)   git_mr_menu_mode=update ;;
        st|status)   git_mr_menu_mode=status ;;
        -a|-A|--all) git_mr_menu_update_all=1 ;;
        # Default: conserve argument
        *) args+=("${1}") ;;
        esac
        shift
    done
    set -- "${args[@]}"

    local source_branch; source_branch=$(git_current_branch)
    local issue_code=${GIT_MR_CODE:-${1:-$(guess_issue_code "$source_branch")}}

    [[ -n $issue_code ]] || exit_error "$ERR_USER" "Issue code or search term required for menu."

    # All non-closed merge requests for issue code
    local menu_items; menu_items=$(mr_menu_merge_requests "$issue_code")

    if [[ -z $menu_items ]]; then
        echo_error "No merge requests found for '$issue_code'."
        return "$ERR_GITLAB"
    fi

    case "$git_mr_menu_mode" in
        show) mr_menu_show "$issue_code" "$menu_items" ;;
        update) if [[ $git_mr_menu_update_all -eq 1 ]]
            then mr_menu_update_all "$issue_code" "$menu_items"
            else mr_menu_update     "$menu_items"; fi ;;
        status) mr_menu_status "$issue_code" "$menu_items" ;;
        *) return "$ERR_MR" ;;
    esac
}

mr_transition() {
    git_mr_readonly show

    local transition=${1}
    local source_branch=${2:-$(git_current_branch)}

    local issue_code=${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}

    local mr_summary; mr_summary=$(gitlab_merge_request_summary "$source_branch")
    if [[ -z $mr_summary ]]; then
        echo_error "Merge request not found"
        mr_print "$source_branch"
        return "$ERR_GITLAB"
    fi

    local mr_iid; mr_iid=$(gitlab_extract_iid "$mr_summary")

    # Load existing merge request details
    local merge_request; merge_request=$(gitlab_merge_request "$mr_iid") || exit $?
    local labels; labels=$(gitlab_extract_labels "$merge_request")

    # Print merge request status summary
    echo
    mr_status_block "$mr_iid" "$merge_request"
    echo "--------------------------------------------------------------------------------"
    echo

    local name labels_to_add labels_to_remove jira_transition_var
    case "$transition" in
        IP)
            name="In Progress"
            labels_to_add="${GITLAB_IP_LABELS}"
            labels_to_remove="${GITLAB_CR_LABELS},${GITLAB_QA_LABELS},${GITLAB_OK_LABELS}"
            jira_transition_var="JIRA_IP_ID"
            ;;
        CR)
            name="Code Review"
            labels_to_add="${GITLAB_CR_LABELS}"
            labels_to_remove="${GITLAB_IP_LABELS},${GITLAB_QA_LABELS},${GITLAB_OK_LABELS}"
            jira_transition_var="JIRA_CR_ID"
            ;;
        QA)
            name="Quality Assurance"
            labels_to_add="${GITLAB_QA_LABELS}"
            labels_to_remove="${GITLAB_IP_LABELS},${GITLAB_CR_LABELS},${GITLAB_OK_LABELS}"
            jira_transition_var="JIRA_QA_ID"
            ;;
        OK)
            name="Accepted"
            labels_to_add="${GITLAB_OK_LABELS}"
            labels_to_remove="${GITLAB_IP_LABELS},${GITLAB_CR_LABELS},${GITLAB_QA_LABELS}"
            jira_transition_var="JIRA_OK_ID"
            ;;
        *)
            echo_error "Invalid transition"
            return "$ERR_JIRA"
            ;;
    esac

    mr_update_labels "$mr_iid" "$labels" "$labels_to_remove" "$labels_to_add"

    [[ $transition == "OK" ]] &&
        mr_gitlab_undraft "$mr_iid" "$mr_summary"

    mr_jira_transition "$issue_code" "$name" "$jira_transition_var"
}

mr_hook() {
    git_mr_readonly show

    local git_dir; git_dir=$(git rev-parse --git-dir)
    local git_mr_dir; git_mr_dir="$(dirname "${BASH_SOURCE[0]}")"

    [[ -d "${git_dir}/hooks" ]] || mkdir "${git_dir}/hooks"

    local hook
    while read -r -d $'\0' hook; do
        local hook_name; hook_name="$(basename "$hook")"
        echo "Linking hook: ${hook_name}"
        git_mr_readonly ||
            ln -sf "$hook" "${git_dir}/hooks/${hook_name}"
    done < <(find "${git_mr_dir}/hooks" -type f -print0)
}

usage() {
    local b; b="$(printf '\e[1m')"
    local u; u="$(printf '\e[4m')"
    local r; r="$(printf '\e[0m')"

    cat <<EOF
${b}NAME${r}
       ${u}git-mr${r} - Manage a Gitlab merge request description, with link to Jira ticket and current branch commit list

${b}SYNOPSIS${r}
       ${u}git${r} ${u}mr${r} [OPTION...]          [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  open    [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  status  [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  update  [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  merge   [BRANCH]

       ${u}git${r} ${u}mr${r} [OPTION...]  menu                 [SEARCH_TERM]
       ${u}git${r} ${u}mr${r} [OPTION...]  menu update [--all]  [SEARCH_TERM]
       ${u}git${r} ${u}mr${r} [OPTION...]  menu status          [SEARCH_TERM]

       ${u}git${r} ${u}mr${r} [OPTION...]  (ip|cr|qa|accept)  [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  undraft            [BRANCH]

       ${u}git${r} ${u}mr${r} hook

       ${u}git${r} ${u}mr${r} base
       ${u}git${r} ${u}mr${r} code

${b}ARGUMENTS${r}
       BRANCH
           Force merge request source branch.
           Defaults to current branch.

       SEARCH_TERM
           Term searched in merge requests titles to build menu.
           Defaults to Jira issue code guessed from branch name.

${b}OPTIONS${r}

       -c, --code   ISSUE_CODE
           Force issue code.

       -t, --target TARGET_BRANCH
           Force target branch.

       -e, --extended
           Use full commit messages in description ("extended", for \`git mr [open|update]\`).
           You can also set GIT_MR_EXTENDED=1 in your environment variables to always use extended commit descriptions.

       -y, --yes
           Bypass confirmation prompts ("yes").

       -n, --new-section
           Add new section in description for new commits (for \`git mr update\`)

       -f, --force
           Force merge even if there are unresolved threads (for \`git mr merge\`)

       -a, --all
           Update all merge requests (for \`git mr menu update\`).

       -v, --verbose
           Verbose output (displays called API URLs & other debugging info).

       -h
           Show this help.

${b}CONFIGURATION${r}

       You need to configure the following environment variables:

           export JIRA_USER="user.name@mycompany.com"
           export JIRA_INSTANCE="mycompany.atlassian.net"
           export JIRA_TOKEN="abcdefghijklmnopqrstuvwx"
           export JIRA_CODE_PATTERN="[A-Z]{2,3}-[0-9]+"

           export GITLAB_DOMAIN="myapp.gitlab.com"
           export GITLAB_TOKEN="Zyxwvutsrqponmlkjihg"

       To create a Jira API Token, go to: https://id.atlassian.com/manage-profile/security/api-tokens
       (Account Settings -> Security -> API Token -> Create and manage API tokens)

       To create a Gitlab API Token, go to: https://myapp.gitlab.com/-/profile/personal_access_tokens?name=Git-MR+Access+token&scopes=api
       (Settings -> Access Tokens)

       Optional configuration variables:

           # Default labels for new merge requests
           export GITLAB_DEFAULT_LABELS="Review,My Team"

           # Gitlab status labels (comma-separated, without spaces in between)
           export GITLAB_IP_LABELS="WIP"       # Label(s) set on IP step
           export GITLAB_CR_LABELS="Review"    # Label(s) set on CR step
           export GITLAB_QA_LABELS="Testing"   # Label(s) set on QA step
           export GITLAB_OK_LABELS="Validated" # Label(s) set on Accepted step

           # Jira status - transition IDs
           export JIRA_IP_ID="xx" # "In Progress" transition ID
           export JIRA_CR_ID="xx" # "Code Review" transition ID
           export JIRA_QA_ID="xx" # "Quality Assurance" transition ID
           export JIRA_OK_ID="xx" # "Accepted" transition ID

           # Check "Delete source branch" by default (defaults to 1)
           export GITLAB_DEFAULT_FORCE_REMOVE_SOURCE_BRANCH=1

           # Network timeout (in seconds, defaults to 5)
           export GIT_MR_TIMEOUT=5

EOF
}


################################################################################
# Error codes

#ERR=1             # General error
ERR_USER=9         # User error
ERR_GIT=10         # Git error
ERR_GIT_REPO=11    # Git repository error
ERR_GITLAB=20      # Gitlab error
ERR_GITLAB_API=21  # Gitlab request error
ERR_JIRA=30        # Jira error
ERR_JIRA_API=31    # Jira request error
ERR_MR=90          # Git-MR error
ERR_MR_DEPS=91     # Dependency issue
ERR_MR_ENV=92      # Environment configuration issue


################################################################################
# Hardcoded constants
GITLAB_DRAFT_PREFIX="Draft"
GITLAB_DRAFT_PREFIXES=("WIP" "Draft")
MD_BOLD=${MD_BOLD="**"} # Markdown bold
MD_BR=${MD_BR="  "} # Markdown line break
GIT_MR_MENU_START=${GIT_MR_MENU_START:-"## Menu"}
GIT_MR_MENU_END=${GIT_MR_MENU_END:-"--------------------------------------------------------------------------------"}
GIT_MR_MENU_UPDATE_CONTEXT_LINES=${GIT_MR_MENU_UPDATE_CONTEXT_LINES:-15}


################################################################################
# Run

# Exit if not running script directly (ex: when sourcing)
[[ "$(basename "$0")" == 'git-mr' ]] || return 0;

# Init

git rev-parse > /dev/null 2>&1    || exit_error "$ERR_GIT_REPO" "Not a git repository"

[[ -x "$(command -v jq)" ]]       || exit_error "$ERR_MR_DEPS" "Git-MR requires jq [https://stedolan.github.io/jq/]"
[[ "${BASH_VERSINFO:-0}" -ge 4 ]] || exit_error "$ERR_MR_DEPS" "Your bash version is too old: $BASH_VERSION"


# Parse options
args=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -c|--code)   GIT_MR_CODE="$2";   shift ;;
        -t|--target) GIT_MR_TARGET="$2"; shift ;;

        -e|-E|--extended)    GIT_MR_EXTENDED=1 ;;
        -y|-Y|--yes)         GIT_MR_YES=1     ;;
        -n|-N|--new-section) GIT_MR_UPDATE_NEW_SECTION=1 ;;
        -f|-F|--force)       GIT_MR_FORCE=1 ;;
        -v|-V|--verbose)     GIT_MR_VERBOSE=1 ;;

        -h) usage; exit 0; ;;

        *) args+=("${1}") ;;
    esac
    shift
done
set -- "${args[@]}"


# Run
case $1 in

    help|usage) usage ;;

    o|op|open)   mr_open   "${@:2}" ;;
    s|st|status) mr_status "${@:2}" ;;
    u|up|update) mr_update "${@:2}" ;;
    m|mg|merge)  mr_merge  "${@:2}" ;;

    menu) mr_menu "${@:2}" ;;

    p|ip|IP)     mr_transition "IP" "${@:2}" ;;
    r|cr|CR)     mr_transition "CR" "${@:2}" ;;
    q|qa|QA)     mr_transition "QA" "${@:2}" ;;
    a|ac|accept) mr_transition "OK" "${@:2}" ;;

    undraft) gitlab_undraft "${@:2}" ;;

    hook) mr_hook ;;

    # Plumbing
    base) git_base_branch ;;
    code) guess_issue_code ;;

    *) mr_print "$@" ;;

esac
