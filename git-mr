#!/usr/bin/env bash

################################################################################
# Git functions

function git_current_branch
{
    # `git branch --show-current` is available starting from Git 2.22
    # fallback to `git rev-parse --abbrev-ref HEAD` if first command fails
    (git branch --show-current 2>/dev/null) || \
    git rev-parse --abbrev-ref HEAD
}

function git_base_branch
{
    local branch=${1:-$(git_current_branch)}

    [ -z "$branch" ]                                      && exit 3 # Not on any branch
    [ "$branch" == "main" ] || [ "$branch" == "master" ]  && exit 3 # On default branch
    git show-ref -q --heads "$branch"                     || exit 3 # Branch does not exist

    # Nearest branch in commit history
    local base_branch; base_branch=$( \
        git log --oneline --decorate "${branch}" \
            --simplify-by-decoration --decorate-refs='refs/heads/*' | # select only commits with a local branch
        head -n2 | tail -n1                    | # select closest decoration before current HEAD
        sed 's/[a-f0-9]\+ (\([^)]*\)) .*/\1/'  | # filters out everything but decorations
        sed -e 's/, /\n/g'                     | # splits decorations
        head -n1)                                # keep only first decoration

    # First possible merge base
    if ! git show-ref -q --heads "$base_branch"; then
        local remote; remote=$(git remote | head -n1)
        local remote_default; remote_default=$(git symbolic-ref "refs/remotes/${remote}/HEAD" -- 2>/dev/null)
        local default; default=${remote_default#"refs/remotes/${remote}/"}
        base_branch=$(git show-branch --merge-base "$branch" "$default" | head -n1)
    fi

    echo_debug "Base branch: $base_branch"

    echo "$base_branch"
}

function git_check_branches
{
    local source_branch="$1"
    local target_branch="$2"

    [ -z "$source_branch" ] &&
        exit_error 3 "Not on any branch"

    [ "$source_branch" == "main" ] ||
    [ "$source_branch" == "master" ]  &&
        exit_error 3 "On default branch"

    git show-ref -q --heads "$source_branch" ||
        exit_error 3 "Branch '$source_branch' does not exist"

    [ -z "$target_branch" ] &&
        exit_error 3 "Unable to determine target branch"

    return 0
}

function git_commits
{
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}

    git log --oneline --reverse --no-decorate "heads/${target_branch}..heads/${source_branch}"
}

function git_commits_extended
{
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}

    local prefix="* ${MD_BOLD}"
    local suffix="${MD_BOLD}${MD_BR}"

    local end="---COMMIT-BODY-END---" # useful to remove trailing blank line

    local format="${prefix}%h %s${suffix}%n%b${end}"

    git log --reverse --no-decorate --format="${format}" "${target_branch}".."${source_branch}" |
        grep -v "^${end}" | # remove trailing blank line
        sed -r "s/${end}$//g" # remove trailing body end for bodies without trailing blank line
}

function git_commit_extended
{
    local revision=${1:-HEAD}

    local prefix="* ${MD_BOLD}"
    local suffix="${MD_BOLD}${MD_BR}"

    local end="---COMMIT-BODY-END---" # useful to remove trailing blank line

    local format="${prefix}%h %s${suffix}%n%b${end}"

    git show -s --format="${format}" "${revision}" |
        grep -v "^${end}" | # remove trailing blank line
        sed -r "s/${end}$//g" # remove trailing body end for bodies without trailing blank line
}

function git_titlize_branch
{
    local branch=${1:-$(git_current_branch)}

    # Split prefix, issue id & label parts

    local branch_split_pattern="^(.*)($JIRA_CODE_PATTERN)[^a-zA-Z0-9]?(.*)$"

    local prefix;   prefix=$(  echo "$branch" | sed -r "s/$branch_split_pattern/\1/") # ex: 'feature/'
    local issue_id; issue_id=$(echo "$branch" | sed -r "s/$branch_split_pattern/\2/") # ex: 'XY-1234'
    local label;    label=$(   echo "$branch" | sed -r "s/$branch_split_pattern/\3/") # ex: 'my-branch-name'

    # When Jira code pattern is not matched
    if [ "$prefix" = "$issue_id" ]; then
        # Split prefix & label parts
        branch_split_pattern="^([^\/]*\/?)(.*)$"
        prefix=$(echo "$branch" | sed -r "s/$branch_split_pattern/\1/")
        label=$( echo "$branch" | sed -r "s/$branch_split_pattern/\2/")
        issue_id=
    else
        issue_id="$issue_id " # add space
    fi

    # When Jira code pattern and prefix are not matched
    if [ -z "$label" ]; then
        label="$prefix"
        prefix=
    fi

    # Formatting
    local title_ref;   title_ref="${prefix^}${issue_id}"
    local title_label; title_label="$(echo "${label^}" | sed 's/[-_]/ /g')"

    echo "${title_ref}${title_label}"
}


################################################################################
# Misc. utilities

function exit_error
{
	local code=$1
	local msg="$2"

	echo_error "$msg"
	exit "$code"
}

# https://gist.github.com/cdown/1163649#gistcomment-1639097
urlencode() {
    local oLANG="$LANG"
    local oLC_ALL="$LC_ALL"
    LANG=C
    LC_ALL=C
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            *) printf '%%%02X' "'$c" ;;
        esac
    done
    LANG="$oLANG"
    LC_ALL="$oLC_ALL"
}

function colorize
{
    local input=$1

    if which tput > /dev/null 2>&1 && [ ! -z "$TERM" ] && [ "$(tput -T"$TERM" colors)" -ge 8 ]; then

        local bold='\e[1m'; local nobold='\e[21m'

        local red='\e[31m';    local lightred='\e[91m'
        local green='\e[32m';  local lightgreen='\e[92m'
        local orange='\e[33m'; local lightyellow='\e[93m'
        local blue='\e[34m';   local lightblue='\e[94m'
        local purple='\e[35m'; local lightpurple='\e[95m'
        local cyan='\e[36m';   local lightcyan='\e[96m'
        local gray='\e[090m';  local lightgray='\e[37m'

        local reset='\e[0m'

        for style in "${@:2}"; do
            echo -en "${!style}"
        done
        echo -en "$input"
        echo -en "$reset"

    else
        echo "$input"
    fi
}

# https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda
function terminal_link
{
    local href=$1
    local text=$2

    if which tput > /dev/null 2>&1 && [ ! -z "$TERM" ] && [ "$(tput -T"$TERM" colors)" -ge 8 ]; then
        printf "\e]8;;${href}\e\\${text}\e]8;;\e\\"
    else
        echo -n "$text"
    fi
}

function echo_error
{
    colorize "$1\n" "orange" >&2
}

function echo_debug
{
    if [ -z "$GIT_MR_VERBOSE" ]; then return; fi

    colorize "$1\n" "gray" >&2
}

function echo_spacer
{
    local count=$1
    local char=${2:-" "}

    for ((i=1; i <= count; i++)); do
      echo -n "$char"
    done
}

function confirm
{
    local question=$1

    if [ "$GIT_MR_YES" = "1" ]; then
        echo_error "$(colorize "$question" "cyan") -> yes"
        echo "yes"
        return
    fi

    read -r -p "$(colorize "$question" "lightcyan" "bold") [y/N] " response
    case "$response" in
        [yY][eE][sS]|[yY]) echo "yes" ;;
        *)                 echo "no" ;;
    esac
}

function jq_build
{
    local key=${1}
    local value=${2}
    local initial_data=${3:-"{}"}

    is_obj=$(echo "$value" | grep  '^\{.*\}$')
    is_num=$(echo "$value" | grep  '^[0-9]*$')

    local current_object;

    if [ ! -z "$is_obj" ] || [ ! -z "$is_num" ]; then
        current_object="$(jq --null-input --compact-output --argjson value "$value"   "{\"${key}\": \$value}")"
    else
        current_object="$(jq --null-input --compact-output --arg     value "$value"   "{\"${key}\": \$value}")"
    fi

    jq --null-input --compact-output \
            --argjson initial_data "$initial_data"     \
            --argjson current_object "$current_object" \
            '$initial_data + $current_object'
}

# escape regex special characters for literal usage
function regex_escape
{
    echo "${1}" | sed -e 's/[]\/$*.^[]/\\&/g'
}

function replace_labels
{
    local labels=$1
    local to_remove=$2
    local to_add=$3

    echo_debug "replace_labels - original labels  : $labels"
    echo_debug "replace_labels - labels to remove : $to_remove"
    echo_debug "replace_labels - labels to add    : $to_add"

    # split
    labels=$(    echo "$labels"    | tr "," "\n")
    to_remove=$( echo "$to_remove" | tr "," "\n")
    to_add=$(    echo "$to_add"    | tr "," "\n")

    # remove
    [ ! -z "$to_remove" ] && labels=$(echo "$labels" | grep -v "$to_remove")
    [ ! -z "$to_add" ]    && labels=$(echo "$labels" | grep -v "$to_add")

    # add
    [ ! -z "$to_add" ] && labels=$(echo -e "${labels}\n${to_add}")

    # implode
    labels=$(echo "$labels" | tr "\n" "," | sed 's/^,//' | sed 's/,$//')

    echo_debug "replace_labels - result    : $labels"

    echo "$labels"
}

function open_in_browser
{
    local url=$1

    if [ -z "$url" ]; then
        return;
    fi

    local open_command
    if   [[ "$OSTYPE" == "linux-gnu"* ]]; then open_command='xdg-open';
    elif [[ "$OSTYPE" == "darwin"*    ]]; then open_command='open';
    fi

    if [ ! -z "$open_command" ] && [ -x "$(command -v $open_command)" ]; then
        $open_command "${url}" > /dev/null 2>&1
        return;
    fi

    echo_error "Unable to open browser"
    echo_error
    echo "${url}"
    echo
}


################################################################################
# Markdown formatting

function markdown_title
{
    local label=$1
    local level=${2:-1}

    for ((i=1; i<=level; i++)); do
        echo -n '#'
    done

    echo " ${label}"
}

function markdown_link
{
    local label=$1
    local url=$2

    if [ -z "$url" ]; then
        echo "[$label]"
        return
    fi

    echo "[$label]($url)"
}

function markdown_list
{
    local content=$1

    local prefix="* ${MD_BOLD}"
    local suffix="${MD_BOLD}${MD_BR}"

    echo "$content" | sed "s/.*/${prefix}&${suffix}/"
}

function markdown_indent_list_items
{
    local content=$1

    local list_prefix_pattern
    list_prefix_pattern="$(regex_escape "* ${MD_BOLD}")"

    # indent extended description (not starting with list prefix)
    local indent="  "
    echo "$content" | sed -E \
        -e "/^${list_prefix_pattern}/! s/^(.*)$/${indent}\1${MD_BR}/gm" \
        -e "s/^${indent}${MD_BR}$/${indent}/gm"
}


################################################################################
# Jira functions

function jira_check_env
{
    [ ! -z "$JIRA_USER" ]     || exit_error 21 "JIRA_USER is not set"
    [ ! -z "$JIRA_TOKEN" ]    || exit_error 21 "JIRA_TOKEN is not set"
    [ ! -z "$JIRA_INSTANCE" ] || exit_error 21 "JIRA_INSTANCE is not set"
}

function jira_request
{
    jira_check_env

    local request_url=$1
    local request_verb=${2:-"GET"}
    local request_data=${3}

    local jira_base_url="https://${JIRA_INSTANCE}/rest/api/3"

    local auth_token; auth_token=$(echo -n "${JIRA_USER}:${JIRA_TOKEN}" | base64 -w 0)

    echo_debug "Jira - ${request_verb} ${request_url} ${request_data}"

    curl -Ss \
        -X "${request_verb}" \
        -H "Authorization: Basic ${auth_token}" \
        -H "Content-Type: application/json" \
        --data "${request_data}" \
        --max-time "${GIT_MR_TIMEOUT:-5}" \
        "${jira_base_url}/${request_url}" || exit_error 20 "Jira request error"
}

function jira_ticket_data
{
    jira_check_env

    local issue_code=$1;  [ ! -z "$issue_code" ] || exit_error 0 "issue_code required"

    jira_request "issue/${issue_code}?fields=summary" || exit $?
}

function jira_transition
{
    jira_check_env

    local issue_code=$1;     [ ! -z "$issue_code"    ] || exit_error 0 "issue_code required"
    local transition_id=$2;  [ ! -z "$transition_id" ] || exit_error 0 "transition_id required"

    local transition;   transition=$(jq_build "id" "$transition_id")        || exit $?
    local request_data; request_data=$(jq_build "transition" "$transition") || exit $?

    jira_request "issue/${issue_code}/transitions" "POST" "$request_data" || exit $?
}


################################################################################
# Gitlab functions

function gitlab_check_env
{
    [ ! -z "$GITLAB_DOMAIN" ] || exit_error 11 "GITLAB_DOMAIN is not set"
    [ ! -z "$GITLAB_TOKEN" ]  || exit_error 11 "GITLAB_TOKEN is not set"
}

function gitlab_project_url
{
    local remote_url
    local project_url

    remote_url=$(git remote get-url --push origin | grep "${GITLAB_DOMAIN}")

    if [[ "$remote_url" = git* ]]; then
      project_url=$(echo $remote_url | sed "s/git\@${GITLAB_DOMAIN}:\(.*\).git/\1/")
    fi

    if [[ "$remote_url" = https* ]]; then
      project_url=$(echo $remote_url | sed "s/https:\/\/${GITLAB_DOMAIN}\/\(.*\).git/\1/")
    fi

    if [ -z "$project_url" ]; then
        local remote; remote=$(git remote get-url --push origin)
        local domain; domain=$(echo "$remote" | sed 's/.*@\(.*\):.*/\1/')
        read -r -d '' message <<EOF
Unable to determine Gitlab project URL, check GITLAB_DOMAIN configuration
  origin:     $remote
  current:    GITLAB_DOMAIN="$GITLAB_DOMAIN"
  Suggestion: GITLAB_DOMAIN="$domain"
EOF
        exit_error 12 "$message" # Unable to determine Gitlab project URL
    fi

    echo "$project_url"
}

function gitlab_project_request
{
    gitlab_check_env

    local project_url; project_url=$(gitlab_project_url) || exit $?
    local project_id;  project_id=$(urlencode "$project_url")

    if [ -z "$project_id" ]; then return; fi

    local request_url=$1
    local request_verb=${2:-"GET"}
    local request_data=${3}

    local gitlab_base_url="https://${GITLAB_DOMAIN}/api/v4"

    local gitlab_project_url="${gitlab_base_url}/projects/${project_id}"

    echo_debug "GitLab - ${request_verb} ${gitlab_project_url}/${request_url} ${request_data}"

    result=$(curl -Ss \
        -X "${request_verb}" \
        -H "Private-Token: ${GITLAB_TOKEN}" \
        -H "Content-Type: application/json" \
        --data "${request_data}" \
        --max-time "${GIT_MR_TIMEOUT:-5}" \
        "${gitlab_project_url}/${request_url}") || exit_error 10 "Gitlab request error"

    if [ ! -z "$(gitlab_check_error "$result")" ]; then return; fi

    echo "$result"
}

function gitlab_request
{
    gitlab_check_env

    local request_url=$1
    local request_verb=${2:-"GET"}
    local request_data=${3}

    local gitlab_base_url="https://${GITLAB_DOMAIN}/api/v4"

    echo_debug "GitLab - ${request_verb} ${gitlab_base_url}/${request_url} ${request_data}"

    result=$(curl -Ss \
        -X "${request_verb}" \
        -H "Private-Token: ${GITLAB_TOKEN}" \
        -H "Content-Type: application/json" \
        --data "${request_data}" \
        --max-time "${GIT_MR_TIMEOUT:-5}" \
        "${gitlab_base_url}/${request_url}") || exit_error 10 "Gitlab request error"

    if [ ! -z "$(gitlab_check_error "$result")" ]; then return; fi

    echo "$result"
}

function gitlab_check_error
{
    local result=$1

    local hasErrorMessage; hasErrorMessage=$(echo "$result" | jq 'if type=="object" then (has("error") or has("message")) else false end')

    if [ "$hasErrorMessage" = 'true' ]; then
        echo_error "\nGitlab error:\n  ${result}"

        echo "ko"
    fi
}

function gitlab_new_merge_request_url
{
    gitlab_check_env

    local project_url;   project_url=$(gitlab_project_url) || exit $?

    if [ -z "$project_url" ]; then return; fi

    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}

    local gitlab_mr_url="https://${GITLAB_DOMAIN}/${project_url}/-/merge_requests/new"

    gitlab_mr_url="${gitlab_mr_url}?$(urlencode "merge_request[source_branch]")=${source_branch}"
    gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[target_branch]")=${target_branch}"

    # default labels
    for label_id in $(gitlab_default_label_ids); do
        gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[label_ids][]")=${label_id}"
    done

    # other options
    if [ "${GITLAB_DEFAULT_FORCE_REMOVE_SOURCE_BRANCH:-1}" -eq 1 ]; then
        gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[force_remove_source_branch]")=1"
    fi

    # title
    local title
    title=$(git_titlize_branch "$source_branch")
    title=$(gitlab_title_to_draft "$title")
    title=$(urlencode "$title")
    gitlab_mr_url="${gitlab_mr_url}&$(urlencode "merge_request[title]")=${title}"

    echo "$gitlab_mr_url"
}

function gitlab_merge_requests_for_branch
{
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    local result
    result=$(gitlab_project_request "merge_requests?state=opened&view=simple&source_branch=${source_branch}") || exit $?

    if [ -z "$result" ] || [ "$result" = "[]" ]; then
        return
    fi

    echo "$result"
}

function gitlab_merge_requests_search
{
    gitlab_check_env

    local search_term=$1; [ ! -z "$search_term" ] || exit_error 0 "search_term required"

    local result
    result=$(gitlab_request "merge_requests?scope=all&state=all&view=simple&search=$(urlencode "$search_term")&in=title&order_by=created_at&sort=asc") || exit $?

    if [ -z "$result" ] || [ "$result" = "[]" ]; then
        return
    fi

    result=$(echo "$result" | jq -c 'map(select(.state != "closed") | {iid: .iid, title: .title, web_url: .web_url, state: .state, project_id: .project_id}) | .[]')
    if [ -z "$result" ] || [ "$result" = "[]" ]; then
        return
    fi

    echo "$result"
}

function gitlab_projects
{
    local result

    result=$(gitlab_request "projects?simple=true&archived=false&order_by=last_activity_at&per_page=100") || exit $?
    if [ -z "$result" ] || [ "$result" = "[]" ]; then
        return
    fi

    result=$(echo "$result" | jq 'map({id: .id, name: .name, path_with_namespace: .path_with_namespace})')
    if [ -z "$result" ] || [ "$result" = "[]" ]; then
        return
    fi

    echo "$result"
}

function gitlab_merge_request
{
    gitlab_check_env

    local mr_iid=$1

    if [ -z "$mr_iid" ]; then return; fi

    gitlab_project_request "merge_requests/$mr_iid"
}

function gitlab_extract_iid
{
    local mr_summary=$1
    echo "$mr_summary" | jq -r '.[0].iid'
}

function gitlab_extract_url
{
    local mr_summary=$1
    echo "$mr_summary" | jq -r '.[0].web_url'
}

function gitlab_extract_title
{
    local mr_detail=$1
    echo "$mr_detail" | jq -r '.title'
}

function gitlab_extract_description
{
    local mr_detail=$1
    echo "$mr_detail" | jq -r '.description'
}

function gitlab_extract_merge_status
{
    local mr_detail=$1

    if [ "$(echo "$mr_detail" | jq -r '.state')" = "merged" ]; then
        echo "merged"
        return
    fi

    echo "$mr_detail" | jq -r '.merge_status'
}

function gitlab_extract_pipeline_status
{
    local mr_detail=$1

    echo "$mr_detail" | jq -r '.head_pipeline.status'
}

function gitlab_extract_pipeline_url
{
    local mr_detail=$1

    echo "$mr_detail" | jq -r '.head_pipeline.web_url'
}

function gitlab_extract_target_branch
{
    local mr_detail=$1
    echo "$mr_detail" | jq -r '.target_branch'
}

function gitlab_extract_labels
{
    local mr_detail=$1
    echo "$mr_detail" | jq -r '.labels | join(",")'
}

function gitlab_extract_project_url
{
    local mr_url=$1

    project_url=$(echo "$mr_url" |
        sed "s/https:\/\/$GITLAB_DOMAIN\///" | # remove prefix
        sed "s/\/-\/merge_requests\/[0-9]*\$//") # remove suffix

    project_url=$(urlencode "$project_url")

    echo "$project_url"
}

function gitlab_merge_request_threads
{
    gitlab_check_env

    local project_url=$1
    local mr_iid=$2

    if [ -z "$project_url" ]; then return; fi
    if [ -z "$mr_iid" ]; then return; fi

    local thread_summaries
    local per_page=100
    local page=1
    local notes_page_count=${per_page}

    while [ "$notes_page_count" -eq "$per_page" ]; do

        # fetch page
        local notes_page
        notes_page=$(gitlab_request "projects/${project_url}/merge_requests/$mr_iid/discussions?per_page=${per_page}&page=${page}")

        if [ "$notes_page" != "[]" ]; then

            local thread_summaries_page
            thread_summaries_page=$(echo "$notes_page" | jq -r '
                map(
                    select(any(.notes[]; .resolvable == true)) |
                    {
                        id: .id,
                        unresolved: any(.notes[]; .resolvable == true and .resolved == false),
                        first_unresolved_note_id: .notes | map(select(.resolvable == true and .resolved == false) | .id) | .[0]
                    }
                ) | .[] |
                .id + "\t" + "unresolved:" + (.unresolved | tostring) + "\t" + "note_id:" + (.first_unresolved_note_id | tostring)')

            # append page
            if [ -z "$thread_summaries" ]; then
                thread_summaries="$thread_summaries_page"
            else
                thread_summaries=$(echo -e "${thread_summaries}\n${thread_summaries_page}")
            fi

            # increment
            notes_page_count=$(echo "$notes_page" | jq -r 'length')
            page=$((page+1))
        else
            notes_page_count=0
        fi
    done

    echo "$thread_summaries"
}

function gitlab_default_label_ids
{
    gitlab_check_env

    local gitlab_labels; gitlab_labels=$(gitlab_project_request "labels")

    # split in multiple lines
    gitlab_labels=$(echo "$gitlab_labels" | sed "s/},/},\n/g")

    # extact ids
    oIFS="$IFS"; IFS=','; read -ra default_labels <<< "$GITLAB_DEFAULT_LABELS"; IFS="$oIFS"; unset oIFS
    for label in "${default_labels[@]}"; do

        local label_id; label_id=$(echo "$gitlab_labels" | jq -r '.[] | select(.name == "'"$label"'") | .id')

        if [ ! -z "$label_id" ]; then
            echo "$label_id"
        fi
    done
}

function gitlab_merge_request_update
{
    gitlab_check_env

    local mr_iid=$1;   if [ -z "$mr_iid" ];  then echo_error "No mr_iid provided"; return; fi
    local mr_data=$2;  if [ -z "$mr_data" ]; then echo_error "No data provided";   return; fi

    gitlab_project_request "merge_requests/${mr_iid}" "PUT" "${mr_data}"
}

function gitlab_merge_request_merge
{
    gitlab_check_env

    local mr_iid=$1;  if [ -z "$mr_iid" ]; then echo_error "No mr_iid provided"; return; fi

    gitlab_project_request "merge_requests/${mr_iid}/merge?should_remove_source_branch=${GITLAB_DEFAULT_FORCE_REMOVE_SOURCE_BRANCH:-1}" "PUT"
}

function gitlab_title_is_draft
{
    local title=$1
    for prefix in "${GITLAB_DRAFT_PREFIXES[@]}"; do
        if echo "$title" | grep -q "^${prefix}:"; then
            return 0
        fi
    done
    return 1;
}

function gitlab_title_to_draft
{
    local title=$1
    echo "${GITLAB_DRAFT_PREFIX}: $title"
}

function gitlab_title_undraft
{
    local title=$1
    for prefix in "${GITLAB_DRAFT_PREFIXES[@]}"; do
        title=$(echo "$title" | sed "s/^${prefix}:\s*//g")
    done
    echo "$title"
}

function gitlab_undraft
{
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    # Search existing merge request

    local mr_summary; mr_summary=$(gitlab_merge_requests_for_branch "$source_branch") || exit $?
    local mr_iid;     mr_iid=$(gitlab_extract_iid "$mr_summary")
    local mr_url;     mr_url=$(gitlab_extract_url "$mr_summary")

    if [ -z "${mr_iid}" ] || [ -z "${mr_url}" ]; then
        echo_error "Merge request not found"
        mr_print "$source_branch"
        return
    fi

    # Load existing merge request details

    local merge_request; merge_request=$(gitlab_merge_request "$mr_iid")
    local mr_title;      mr_title=$(gitlab_extract_title "$merge_request")

    echo
    echo "-------------------------------------------------------------------"
    gitlab_title_undraft "$mr_title"
    echo "-------------------------------------------------------------------"
    echo
    mr_actions "$source_branch" "$mr_summary" "$merge_request"
    echo

    if ! gitlab_title_is_draft "$mr_title"; then
        echo_error "Merge request is not a draft"
        echo_error
        return
    fi

    local undraft_title; undraft_title=$(gitlab_title_undraft "$mr_title")

    if [ "$(confirm "Do you want to resolve draft status?")" = "yes" ]; then
        echo -n "Resolving draft status... "

        mr_data=$(jq_build "title" "$undraft_title") || exit $?
        local result; result=$(gitlab_merge_request_update "${mr_iid}" "${mr_data}")

        if [ ! -z "$result" ]; then echo -e "OK\n"; fi
    fi

    echo
}


################################################################################
# Merge request utility functions

function guess_issue_code
{
    [ -n "$git_mr_unguessable_issue_code" ] && return
    [ -n "$JIRA_CODE_PATTERN" ] || exit_error 0 "JIRA_CODE_PATTERN not set - unable to guess issue code"

    local branch=${1:-$(git_current_branch)}

    local issue_code; issue_code=$(echo "${branch}" |
        grep -Eo "$JIRA_CODE_PATTERN" |
        tail -n1)

    if [ -z "$issue_code" ]; then
        echo_error "Unable to guess issue code"
        return
    fi

    echo_debug "Issue code: $issue_code"

    echo "$issue_code"
}

function mr_title
{
    local source_branch=${1:-$(git_current_branch)}
    local issue_code=${2:-${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}}

    if [ -z "$issue_code" ]; then
        git_titlize_branch "$source_branch"
        return
    fi

    local issue_content; issue_content=$(jira_ticket_data "$issue_code")

    local issue_key;     issue_key=$(echo "$issue_content" | jq -r '.key // empty' )
    local issue_title;   issue_title=$(echo "$issue_content" | jq -r '.fields.summary // empty')

    if [ -z "$issue_key" ]; then
        issue_key=${issue_code^^}
    fi

    if [ -z "$issue_title" ]; then
        echo_error "Unable to get issue title from Jira"
        echo_error "  issue_code: $issue_code"
        if [ ! -z "$issue_content" ]; then
            echo_error "  $issue_content"
        fi

        echo "$issue_key"
        return
    fi

    issue_url="https://${JIRA_INSTANCE}/browse/${issue_key}"

    markdown_link "${issue_key} ${issue_title}" "$issue_url"
}

function mr_commit_list
{
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}

    if [[ $GIT_MR_EXTENDED -eq 1 ]]; then
        markdown_indent_list_items "$(git_commits_extended "$source_branch" "$target_branch")"
    else
        markdown_list "$(git_commits "$source_branch" "$target_branch")"
    fi
}

function mr_description
{
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}
    local issue_code=${3:-${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}}

    local title; title=$(mr_title "$source_branch" "$issue_code") || exit $?

    mr_print_description "$title" "$(mr_commit_list "$source_branch" "$target_branch")"
}

function mr_print_description
{
    local title=$1
    local commit_list=$2

    cat << EOF
$(markdown_title "$title")


## Commits

$commit_list

EOF
}

function mr_actions
{
    local source_branch=${1:-$(git_current_branch)}

    local mr_summary=${2}
    local mr_detail=${3}

    if [ -z "$mr_summary" ]; then
        mr_summary=$(gitlab_merge_requests_for_branch "$source_branch") || exit $?
    fi

    local mr_iid; mr_iid=$(gitlab_extract_iid "${mr_summary}")
    local mr_url; mr_url=$(gitlab_extract_url "$mr_summary")

    if [ ! -z "${mr_url}" ]; then
        echo -e "Merge request:\n\n  $(colorize "${mr_url}" "lightgray")"
        mr_show_status "${mr_iid}" "$mr_detail"
        return
    fi

    local target_branch=${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}
    local new_mr_url
    new_mr_url=$(gitlab_new_merge_request_url "${source_branch}" "${target_branch}")

    cat << EOF
To create a new merge request:

  ${new_mr_url}

EOF
}

function is_status_label
{
    local label=$1

    local system_labels; system_labels=$(echo "${GITLAB_OK_LABELS},${GITLAB_CR_LABELS},${GITLAB_QA_LABELS}" |
        sed 's/,,/,/g' |
        sed 's/^,//' | sed 's/,$//' |
        tr "," "\n")

    local match;   match="$( echo "$label"         | grep "$system_labels")" || return
    local reverse; reverse=$(echo "$system_labels" | grep "$match")          || return
    # reverse-match is important, we don't want "Jean-Pierre BACRI Team" to match "CR" label

    echo "$match"
}

function mr_format_labels
{
    local labels=$1

    IFS=',' read -r -a labels_array <<< "$labels"

    local status_labels=()
    local other_labels=()

    for label in "${labels_array[@]}"; do
        if [ ! -z "$(is_status_label "$label")" ]; then
            status_labels+=($(colorize "[$label]" "lightpurple" "bold"))
        else
            other_labels+=("[$label]")
        fi
    done

    local status_labels_str; status_labels_str="$(printf "%s " "${status_labels[@]}")"
    local other_labels_str;  other_labels_str="$(printf "%s " "${other_labels[@]}")"

    echo "${status_labels_str}${other_labels_str}" |
        sed 's/^\s*//' | sed 's/\s*$//' # remove leading and trailing spaces
}

function mr_show_status
{
    local mr_iid=$1
    local merge_request; merge_request=${2:-$(gitlab_merge_request "$mr_iid")}

    local mr_url; mr_url=$(echo "$merge_request" | jq -r '.web_url')
    local project_url; project_url=$(gitlab_extract_project_url "$mr_url")

    local threads; threads=${3:-$(gitlab_merge_request_threads "$project_url" "$mr_iid")}

    mr_print_status "$merge_request" "$threads"
}

function mr_print_status
{
    local merge_request=$1
    local threads=$2

    [ -n "$merge_request" ] || exit_error 0 "merge_request not provided"

    local mr_url;        mr_url=$(echo "$merge_request" | jq -r '.web_url')
    local project_url;   project_url=$(gitlab_extract_project_url "$mr_url")

    # Labels
    local labels; labels=$(gitlab_extract_labels "$merge_request")
    local labels_display; labels_display=$(mr_format_labels "$labels")

    local labels_count; labels_count=$(echo $labels | sed 's/[^,]//g' | wc -m)
    local labels_str_len=$(( ${#labels} + $(($labels_count*2)) + 4 )) # 2 spaces + 2 for larger icon

    # Votes

    local upvotes;   upvotes=$(echo "$merge_request" | jq -r '.upvotes' )
    local downvotes; downvotes=$(echo "$merge_request" | jq -r '.downvotes' )

    if [ "$upvotes" -gt 1 ];   then upvotes=$(colorize "$upvotes" "bold" "lightgreen")
    elif [ "$upvotes" -gt 0 ]; then upvotes=$(colorize "$upvotes" "bold" "lightyellow")
                               else upvotes=$(colorize "$upvotes" "bold"); fi

    if [ "$downvotes" -gt 0 ];
        then downvotes=$(colorize "$downvotes" "bold" "lightred")
        else downvotes=$(colorize "$downvotes" "bold"); fi

    # Threads
    local thread_count;   thread_count="$(echo "$threads" | grep -c 'unresolved:' || true)"
    local resolved_count; resolved_count="$(echo "$threads" | grep -c 'unresolved:false' || true)"

    local thread_count_display;
        thread_count_display=$(colorize "$thread_count" "bold")

    local resolved_count_display; if [ "$resolved_count" -lt "$thread_count" ];
        then resolved_count_display=$(colorize "$resolved_count" "bold" "lightred")
        else resolved_count_display=$(colorize "$resolved_count" "bold" "lightgreen"); fi

    local threads_display="${resolved_count_display}/${thread_count_display}"

    if [ "$resolved_count" -lt "$thread_count" ]; then
        local first_unresolved_note_id
        first_unresolved_note_id=$(echo "$threads" | grep 'unresolved:true' | cut -f 3 | cut -d ':' -f 2 )
        local note_url="${mr_url}#note_${first_unresolved_note_id}"
        threads_display=$(terminal_link "$note_url" "$threads_display")
    fi

    # Title
    local title; title=$(gitlab_extract_title "$merge_request")

    # Merge status
    local merge_status; merge_status=$(gitlab_extract_merge_status "$merge_request")
    local merge_status_icon; if [ "$merge_status" = "merged" ] || [ "$merge_status" = "can_be_merged" ];
        then merge_status_icon="$(colorize "\U00002714" "lightgreen" "bold")"; # heavy check mark
        else merge_status_icon="$(colorize "\U0000274C" "lightred" "bold")"; fi # cross mark

    # Pipeline status
    local pipeline_status; pipeline_status="$(gitlab_extract_pipeline_status "$merge_request")"
    local pipeline_url; pipeline_url="$(gitlab_extract_pipeline_url "$merge_request")"
    local pipeline_icon
    case "$pipeline_status" in
        created|waiting_for_resource|preparing|pending|running)
                          pipeline_icon="$(colorize "â±" "lightgray")" ;;
        success)          pipeline_icon="$(colorize "âœ”" "lightgreen" "bold")" ;;
        failed)           pipeline_icon="$(colorize "âŒ" "lightred" "bold")" ;;
        canceled|skipped) pipeline_icon="$(colorize "âž–" "lightgray")" ;;
        manual)           pipeline_icon="$(colorize "ðŸ”§" "lightgray")" ;;
        scheduled)        pipeline_icon="$(colorize "â°" "lightgray")" ;;
        null)             pipeline_icon= ;;
        *)                pipeline_icon="$(colorize "?" "lightgray")" ;;
    esac
    local ci_str=
    local ci_str_len=0
    if [ -n "$pipeline_icon" ]; then
        ci_str="CI: $pipeline_icon"
        ci_str_len=10 # 5 chars + 4 spaces + 1 for larger icon
    fi

    # Merge target
    local current_target; current_target=$(gitlab_extract_target_branch "$merge_request")

    local target_display;
    target_display="${target_display}$(colorize "(\U000021A3 " "gray")"
    target_display="${target_display}$(colorize "$current_target" "lightpurple" )"
    target_display="${target_display}$(colorize ")" "gray")"

    local target_str_len=$(( ${#current_target} + 4 ))

    # Draft status
    local draft_str=
    local draft_str_len=0
    if gitlab_title_is_draft "$title"; then
        draft_str="ðŸš§ Draft"
        draft_str_len=12 # 7 chars + 4 spaces + 1 for larger icon
    fi

    # Spacers for CI & target branch indicators
    # Spacers for draft & target branch indicators
    local display_width=76 # not counting 3 leading spaces
    local spacer_chars=$(( display_width - labels_str_len - target_str_len - draft_str_len ))
    local spacer_chars_l=0
    local spacer_chars_r=0

    if [[ $spacer_chars -gt 0 ]]; then
        spacer_chars_l=$(( 43 - labels_str_len )) # 42: roughly at the same level as CI indicator
        spacer_chars_r=$(( spacer_chars - spacer_chars_l ))
        if [[ $spacer_chars_r -lt 0  ]]; then
            spacer_chars_l=$(( spacer_chars_l + spacer_chars_r ))
            spacer_chars_r=0
        fi
    fi

    # Display
    echo

    # 1st row ------------------------------------------------------------------
    # Labels
    echo -en  "   \U0001F3F7  ${labels_display}"
    echo_spacer $spacer_chars_l
    # Draft status
    if [[ -n $draft_str ]]; then
        echo -en "  $(colorize "$draft_str" "orange")  "
    else
        echo_spacer $(( 2 - spacer_chars_l - spacer_chars_r ))
    fi
    echo_spacer $spacer_chars_r
    # Target
    echo -e  "${target_display}\n"

    # 2nd row ------------------------------------------------------------------
    # Votes
    echo -en "   \U0001F44D  ${upvotes}"
    echo -en "   \U0001F44E  ${downvotes}"
    # Threads
    if [ "$thread_count" -gt 0 ]; then
        echo -n "     Resolved threads: ${threads_display}"
    else
      echo -n "                          "
    fi
    # Pipeline
    if [ -n "$ci_str" ]; then
        echo -en "      $(terminal_link "$pipeline_url" "$ci_str")  "
    else
        echo -n "             "
    fi
    # Merge status
    if [ "$merge_status" != "merged" ]; then
        echo -en "     Can be merged: ${merge_status_icon}"
    else
        echo -en "            $(colorize "Merged" "lightgreen")"
    fi
    echo -e "\n"
}

function mr_update_labels
{
    local source_branch=${1:-$(git_current_branch)}

    # strip leading & trailing label commas
    local to_remove; to_remove=$(echo -e "$2" | sed 's/^,*//' | sed 's/,*$//')
    local to_add;    to_add=$(echo -e "$3" | sed 's/^,*//' | sed 's/,*$//')

    if [ -z "$to_remove" ] && [ -z "$to_add" ]; then
        echo_error "No label to add or remove"; return
    fi

    # Search existing merge request

    local mr_summary; mr_summary=$(gitlab_merge_requests_for_branch "$source_branch") || exit $?
    local mr_iid;     mr_iid=$(gitlab_extract_iid "$mr_summary")
    local mr_url;     mr_url=$(gitlab_extract_url "$mr_summary")

    if [ -z "${mr_iid}" ] || [ -z "${mr_url}" ]; then
        echo_error "Merge request not found"
        mr_print "$source_branch"
        return
    fi

    # Load existing merge request details

    local merge_request; merge_request=$(gitlab_merge_request "$mr_iid") || exit $?
    local mr_title;      mr_title=$(gitlab_extract_title "$merge_request")
    local labels;        labels=$(gitlab_extract_labels "$merge_request")

    # Print merge request status summary
    echo
    echo "-------------------------------------------------------------------"
    gitlab_title_undraft "$mr_title"
    echo "-------------------------------------------------------------------"
    echo
    mr_actions "$source_branch" "$mr_summary" "$merge_request"
    echo

    local new_labels; new_labels=$(replace_labels "$labels" "$to_remove" "$to_add")
    if [ "$(confirm "Do you want to update the merge request labels to \"$new_labels\"?")" = "yes" ]; then
        echo -n "Updating merge request labels... "

        mr_data=$(jq_build "labels" "$new_labels") || exit $?
        local result; result=$(gitlab_merge_request_update "${mr_iid}" "${mr_data}")

        if [ ! -z "$result" ]; then echo -e "OK\n"; fi
    fi
}


################################################################################
# Merge request menu utility functions

function mr_menu_merge_requests
{
    local issue_code=${1:-${GIT_MR_CODE:-$(guess_issue_code)}}

    local mr_summaries; mr_summaries=$(gitlab_merge_requests_search "$issue_code") || exit $?
    if [ -z "$mr_summaries" ]; then
        return
    fi

    # Load project names into bash associative array
    declare -A project_arr
    while IFS="=" read -r id name
    do
        project_arr[$id]="$name"
    done < <(gitlab_projects | jq -r 'map((.id | tostring)+"="+.name) | .[]' | sed 's/\r//g')

    # Enrich merge request summaries with project names
    while IFS=$'\n' read -r mr_summary
    do
        local project_id; project_id=$(echo "$mr_summary" | jq -r '.project_id')
        local project_name; project_name=${project_arr[$project_id]}

        echo "$mr_summary" | jq -c --arg project_name "$project_name" '. + {project_name: $project_name}'

    done < <(echo "$mr_summaries")
}

function mr_menu_contents
{
    local menu_items=$1
    local current_mr_url=$2;

    echo "$GIT_MR_MENU_START"
    echo

    while IFS=$'\n' read -r menu_item; do
        local project_name; project_name=$(echo "$menu_item" | jq -r '.project_name')
        local title;        title=$(echo "$menu_item" | jq -r '.title')
        local web_url;      web_url=$(echo "$menu_item" | jq -r '.web_url')

        title=$(gitlab_title_undraft "$title")

        local item_label
        item_label=$(echo "${project_name}: $(markdown_link "${title}" "$web_url")")

        local wrap=''
        if [ "$current_mr_url" == "$web_url" ]; then
            wrap='**' # Markdown bold
        fi

        echo "* ${wrap}${item_label}${wrap}"

    done < <(echo "$menu_items")

    echo
    echo "$GIT_MR_MENU_END"
}

function mr_menu_status
{
    local issue_code=$1
    local menu_items=$2

    local mr_count; mr_count=$(echo "$menu_items" | wc -l)

    echo
    echo "-------------------------------------------------------------------"
    echo "${issue_code} (${mr_count} merge request$([[ $mr_count -gt 1 ]] && echo 's'))"
    echo "-------------------------------------------------------------------"
    echo

    while IFS=$'\n' read -r menu_item; do
        local mr_iid;       mr_iid=$(echo "$menu_item" | jq -r '.iid')
        local project_name; project_name=$(echo "$menu_item" | jq -r '.project_name')
        local title;        title=$(echo "$menu_item" | jq -r '.title')
        local web_url;      web_url=$(echo "$menu_item" | jq -r '.web_url')

        title=$(gitlab_title_undraft "$title")
        local project_url; project_url=$(gitlab_extract_project_url "$web_url")

        # Load existing merge request details
        # Do NOT use `gitlab_merge_request`
        merge_request=$(gitlab_request "projects/${project_url}/merge_requests/$mr_iid")

        echo "* $(colorize "${project_name}" "bold"): $(terminal_link "${web_url}" "${title}" )"
        mr_show_status "${mr_iid}" "$merge_request"
        echo

    done < <(echo "$menu_items")
}

function mr_menu_show
{
    local menu_items=$1

    echo
    mr_menu_contents "$menu_items"
}

function mr_menu_update
{
    local menu_items=$1

    # Look for existing merge request
    local current_branch
    current_branch=$(git_current_branch)

    local current_mr_summary; current_mr_summary=$(gitlab_merge_requests_for_branch "$current_branch") || exit $?
    local current_mr_iid;     current_mr_iid=$(gitlab_extract_iid "$current_mr_summary")
    local current_mr_url;     current_mr_url=$(gitlab_extract_url "$current_mr_summary")

    if [ -z "${current_mr_iid}" ] || [ -z "${current_mr_url}" ]; then
        echo_error "Merge request not found"
        echo
        mr_menu_contents "$menu_items"
        return
    fi

    # Load existing merge request details
    local merge_request;  merge_request=$(gitlab_merge_request "$current_mr_iid")
    local mr_description; mr_description=$(gitlab_extract_description "$merge_request")

    local mr_menu_content;
    mr_menu_content=$(mr_menu_contents "$menu_items" "$current_mr_url")

    local updated_description;
    updated_description="$(mr_menu_replace_description "$mr_description" "$mr_menu_content")"

    echo
    mr_menu_colorize "$updated_description" "$current_mr_url"
    echo
    echo '--------------------------------------------------------------------------------'

    local mr_update_data='{}'
    if [ "$(confirm "Do you want to update the menu in the merge request description?")" = "yes" ]; then
        mr_update_data=$(jq_build "description" "$updated_description" "$mr_update_data") || exit $?
    fi
    if [ "$mr_update_data" != "{}" ]; then
        echo -n "Updating merge request..."
        local result
        result=$(gitlab_merge_request_update "$current_mr_iid" "$mr_update_data")
        if [ ! -z "$result" ]; then echo -e "OK\n"; fi
    fi
}

function mr_menu_update_all
{
    local menu_items=$1

    local mr_iid
    local mr_url
    local project_url
    local merge_request
    local mr_description
    local mr_menu_content
    local updated_description
    local mr_update_data
    local result

    # Use array instead of looping over variable content with `read` to leave standard input open for `confirm`
    readarray menu_array < <(echo "$menu_items")

    for menu_item in "${menu_array[@]}"; do

        mr_iid=$(echo "$menu_item" | jq -r '.iid')
        mr_url=$(echo "$menu_item" | jq -r '.web_url')

        # Beware, `gitlab_merge_request` and `gitlab_merge_request_update` use 'gitlab_project_request', which is project-specific
        # Here, we can expect other target projects here.
        project_url=$(gitlab_extract_project_url "$mr_url")

        # Load existing merge request details
        # Do NOT use `gitlab_merge_request`
        merge_request=$(gitlab_request "projects/${project_url}/merge_requests/$mr_iid")

        mr_description=$(gitlab_extract_description "$merge_request")

        mr_menu_content=$(mr_menu_contents "$menu_items" "$mr_url")
        updated_description="$(mr_menu_replace_description "$mr_description" "$mr_menu_content")"

        echo
        mr_menu_colorize "$updated_description" "$mr_url"
        echo
        echo '--------------------------------------------------------------------------------'
        echo
        echo "Merge request:"
        echo
        echo "  ${mr_url}"
        echo

        mr_update_data='{}'

        if [ "$(confirm "Do you want to update the menu in the merge request description?")" = "yes" ]; then
            mr_update_data=$(jq_build "description" "$updated_description" "$mr_update_data") || exit $?
        fi

        if [ "$mr_update_data" != "{}" ]; then
            echo -n "Updating merge request..."
            # Do NOT use `gitlab_merge_request_update`
            result=$(gitlab_request "projects/${project_url}/merge_requests/${mr_iid}" "PUT" "${mr_update_data}")
            if [ ! -z "$result" ]; then echo -e "OK\n"; fi
        fi
    done
    echo
}

function mr_menu_replace_description
{
    local mr_description=$1
    local menu_content=$2

    local menu_start; menu_start=$(echo "$mr_description" | grep -n "$GIT_MR_MENU_START" | head -n1 | cut -f1 -d:)
    local menu_end; menu_end=$(echo "$mr_description" | grep -n -- "$GIT_MR_MENU_END" | cut -f1 -d: | head -n 1)

    local has_menu=0
    if [ -n "$menu_start" ] && [ -n "$menu_end" ] && [ "$menu_start" -gt "0" ] && [ "$menu_end" -gt "$menu_start" ]; then
        has_menu=1
    fi

    # Iterate over description lines and insert/replace menu
    i=1
    while IFS=$'\n' read -r mr_description_line
    do
        if [ "$has_menu" = "1" ]; then
            if [ "$i" -lt "$menu_start" ] || [ "$i" -gt "$menu_end" ]; then
                # output non-menu line
                echo "$mr_description_line"
            else
                # replace menu once
                if [ "$i" -eq "$menu_end" ]; then
                    echo_debug "Replacing menu"
                    echo "$menu_content"
                fi
            fi
        else
            # output non-menu line
            echo "$mr_description_line"
            # insert menu once
            if [ "$i" -eq "2" ]; then
                echo_debug "Inserting menu"
                echo "$menu_content"
                echo
            fi
        fi

        ((i+=1))

    done < <(echo "$mr_description")
}

function mr_menu_colorize
{
    local mr_description=$1
    local current_mr_url=$2

    local menu_start; menu_start=$(echo "$mr_description" | grep -n "$GIT_MR_MENU_START" | head -n1 | cut -f1 -d:)
    local menu_end; menu_end=$(echo "$mr_description" | grep -n -- "$GIT_MR_MENU_END" | cut -f1 -d: | head -n 1)

    # Iterate over description lines and colorize menu lines
    i=1
    while IFS=$'\n' read -r mr_description_line
    do
        if [ "$i" -lt "$menu_start" ] || [ "$i" -gt "$menu_end" ]; then
            # output non-menu line
            echo -e "$(colorize "$mr_description_line" "lightgray")"
        else
            # colorize menu line
            [[ $mr_description_line =~ $current_mr_url ]] &&
                echo -e "$(colorize "$mr_description_line" "bold" "lightyellow")" ||
                echo -e "$(colorize "$mr_description_line" "lightyellow")"
        fi
        ((i+=1))
    done < <(echo "$mr_description")
}


################################################################################
# Merge request top-level functions

function mr_print
{
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${2:-${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}}
    git_check_branches "$source_branch" "$target_branch"

    local issue_code=${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}
    [ -z "$issue_code" ] && git_mr_unguessable_issue_code=1

    cat << EOF

--------------------------------------------------------------------------------
$(mr_description "$source_branch" "$target_branch" "$issue_code")

--------------------------------------------------------------------------------

EOF

    mr_actions "$source_branch"
}

function mr_open
{
    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}
    git_check_branches "$source_branch" "$target_branch"

    local issue_code=${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}
    [ -z "$issue_code" ] && git_mr_unguessable_issue_code=1

    local mr_summary; mr_summary=$(gitlab_merge_requests_for_branch "$source_branch")
    local mr_iid;     mr_iid=$(gitlab_extract_iid "${mr_summary}")
    local mr_url;     mr_url=$(gitlab_extract_url "$mr_summary")

    if [ -n "${mr_url}" ]; then
        echo
        echo -e "Merge request:\n\n  $(colorize "${mr_url}" "lightgray")"
        mr_show_status "${mr_iid}"
        open_in_browser "${mr_url}"
        return
    fi

    local description; description=$(mr_description "$source_branch" "$target_branch" "$issue_code")

    cat << EOF

--------------------------------------------------------------------------------
${description}

--------------------------------------------------------------------------------

EOF

    local new_mr_url; new_mr_url=$(gitlab_new_merge_request_url "${source_branch}" "${target_branch}")

    if [ ! -z "${new_mr_url}" ]; then

        # add description
        new_mr_url="${new_mr_url}&$(urlencode "merge_request[description]")=$(urlencode "$description")"

        echo_debug
        echo_debug "Opening:"
        echo_debug "$new_mr_url"

        open_in_browser "${new_mr_url}"
    fi
}

function mr_status
{
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    # Search existing merge request

    local mr_summary; mr_summary=$(gitlab_merge_requests_for_branch "$source_branch") || exit $?
    local mr_iid;     mr_iid=$(gitlab_extract_iid "$mr_summary")
    local mr_url;     mr_url=$(gitlab_extract_url "$mr_summary")

    if [ -z "${mr_iid}" ] || [ -z "${mr_url}" ]; then
        echo_error "Merge request not found"
        mr_print "$source_branch"
        return
    fi

    # Load existing merge request details

    local merge_request;  merge_request=$(gitlab_merge_request "$mr_iid")
    local mr_title;       mr_title=$(gitlab_extract_title "$merge_request")
    local current_target; current_target=$(gitlab_extract_target_branch "$merge_request")

    # Print merge request title & status
    echo
    echo "-------------------------------------------------------------------"
    gitlab_title_undraft "$mr_title"
    echo "-------------------------------------------------------------------"
    echo
    mr_actions "$source_branch" "$mr_summary" "$merge_request"
}

function mr_update
{
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}
    local target_branch=${GIT_MR_TARGET:-$(git_base_branch "$source_branch")}

    # Search existing merge request

    local mr_summary; mr_summary=$(gitlab_merge_requests_for_branch "$source_branch") || exit $?
    local mr_iid;     mr_iid=$(gitlab_extract_iid "$mr_summary")
    local mr_url;     mr_url=$(gitlab_extract_url "$mr_summary")

    if [ -z "${mr_iid}" ] || [ -z "${mr_url}" ]; then
        echo_error "Merge request not found"
        mr_print "$source_branch" "$target_branch"
        return
    fi

    # Load existing merge request details

    local merge_request;  merge_request=$(gitlab_merge_request "$mr_iid")
    local mr_title;       mr_title=$(gitlab_extract_title "$merge_request")
    local mr_description; mr_description=$(gitlab_extract_description "$merge_request")
    local current_target; current_target=$(gitlab_extract_target_branch "$merge_request")

    # Init commit lists

    local commit_messages; commit_messages=$(git_commits "$source_branch" "$target_branch")

    local current_commits; current_commits=$(echo "$commit_messages" | cut -d ' ' -f1)
    local old_commits;     old_commits=$(echo "$mr_description" |
        grep -Po '^[^0-9a-fA-F]*[0-9a-fA-F]{7,}\s' |
        sed -r 's/^[^0-9a-fA-F]*([0-9a-fA-F]{7,})\s/\1/g')

    local current_commits_array; current_commits_array=($(echo "$current_commits" | tr "\n" " "))
    local old_commits_array;     old_commits_array=($(echo "$old_commits" | tr "\n" " "))

    local updated_commit_count=0
    local new_commit=
    local new_commit_messages_display=()
    local new_commit_messages_content=()

    local new_description_display="$mr_description"
    local new_description_content="$mr_description"

    local sameColor="lightblue"
    local updatedColor="orange"
    local newColor="green"

    # Iterate over commit lists, compare sha-1 and update description
    for i in ${!current_commits_array[*]}; do

        local curr=${current_commits_array[$i]}
        local old=${old_commits_array[$i]}

        if [ ! -z "$old" ]; then
            if [ "$old" = "$curr" ]; then
                # same sha-1 - only decorate
                new_description_display=$(echo "$new_description_display" | sed "s/$old/$(colorize "$curr" "$sameColor")/")
                new_description_content=$(echo "$new_description_content" | sed "s/$old/$curr/" )
            else
                # different sha-1 - replace & decorate
                new_description_display=$(echo "$new_description_display" | sed "s/$old/$(colorize "$curr" "$updatedColor")/")
                new_description_content=$(echo "$new_description_content" | sed "s/$old/$curr/" )
                updated_commit_count=$((updated_commit_count+1))
            fi
        else
            # new commit
            [[ $GIT_MR_EXTENDED -eq 1 ]] &&
                new_commit="$(git_commit_extended "$curr")" ||
                new_commit="$(echo "$commit_messages" | grep "$curr")"

            new_commit_messages_display+=("$(echo "$new_commit" | sed "s/$curr/$(colorize "$curr" "$newColor")/")")
            new_commit_messages_content+=("$(echo "$new_commit")")
        fi
    done

    local new_commit_count=${#new_commit_messages_display[@]}

    # implode arrays
    local new_commit_messages_display_str; new_commit_messages_display_str=$(printf "%s\n" "${new_commit_messages_display[@]}")
    local new_commit_messages_content_str; new_commit_messages_content_str=$(printf "%s\n" "${new_commit_messages_content[@]}")

    # Print updated merge request description
    echo
    echo "-------------------------------------------------------------------"
    gitlab_title_undraft "$mr_title"
    echo "-------------------------------------------------------------------"
    echo "$new_description_display"
    if [ "$new_commit_count" -gt 0 ]; then
        if [[ $GIT_MR_UPDATE_NEW_SECTION -eq 1 ]]; then
            echo
            echo "## Update"
            echo
        fi
        [[ $GIT_MR_EXTENDED -eq 1 ]] &&
            markdown_indent_list_items "$new_commit_messages_display_str" ||
            markdown_list "$new_commit_messages_display_str"
    fi

    echo
    echo "--------------------------------------------------------------------------------"
    echo
    echo "  updated commits: $(colorize "$updated_commit_count" "$updatedColor")"
    echo "      new commits: $(colorize "$new_commit_count"     "$newColor")"
    echo

    # Propose update if changes are detected

    if [ ! -x "$(command -v jq)" ]; then
        echo_error "Please install jq to be able to update merge request"

    else
        local mr_update_data='{}'

        if [ $((updated_commit_count + new_commit_count)) -gt 0 ] \
        && [ "$(confirm "Do you want to update the merge request description?")" = "yes" ]; then

                local new_description; new_description=$(echo -e "${new_description_content}")
                local newLines=""

                if [ "$new_commit_count" -gt 0 ]; then
                    if [[ $GIT_MR_UPDATE_NEW_SECTION -eq 1 ]]; then
                        new_description=$(echo -e "${new_description}\n\n## Update")
                        newLines="\n"
                    fi
                    [[ $GIT_MR_EXTENDED -eq 1 ]] &&
                        new_description=$(echo -e "${new_description}\n${newLines}$(markdown_indent_list_items "$new_commit_messages_content_str")") ||
                        new_description=$(echo -e "${new_description}\n${newLines}$(markdown_list "$new_commit_messages_content_str")")
                fi
                new_description=$(echo -e "$new_description")$'\n'
                mr_update_data=$(jq_build "description" "$new_description" "$mr_update_data") || exit $?
            fi
        fi

        if [ "$target_branch" != "$current_target" ] \
        && [ "$(confirm "Do you want to update the merge request target branch from '$current_target' to '$target_branch'?")" = "yes" ]; then
            mr_update_data=$(jq_build "target_branch" "$target_branch" "$mr_update_data") || exit $?
        fi

        if [ "$mr_update_data" != "{}" ]; then

            echo -n "Updating merge request..."

            local result; result=$(gitlab_merge_request_update "$mr_iid" "$mr_update_data")

            if [ ! -z "$result" ]; then echo -e "OK\n"; fi

            # reload merge request details
            merge_request=$(gitlab_merge_request "$mr_iid")
        fi
    fi

    echo "--------------------------------------------------------------------------------"
    echo

    mr_actions "$source_branch" "$mr_summary" "$merge_request"
}

function mr_merge
{
    gitlab_check_env

    local source_branch=${1:-$(git_current_branch)}

    # Search existing merge request

    local mr_summary;  mr_summary=$(gitlab_merge_requests_for_branch "$source_branch") || exit $?
    local mr_iid;      mr_iid=$(gitlab_extract_iid "$mr_summary")
    local mr_url;      mr_url=$(gitlab_extract_url "$mr_summary")
    local project_url; project_url=$(gitlab_extract_project_url "$mr_url")

    if [ -z "${mr_iid}" ] || [ -z "${mr_url}" ]; then
        echo_error "Merge request not found"
        mr_print "$source_branch"
        return
    fi

    # Load existing merge request details

    local merge_request;  merge_request=$(gitlab_merge_request "$mr_iid")
    local title;          title=$(gitlab_extract_title "$merge_request")
    local merge_status;   merge_status=$(gitlab_extract_merge_status "$merge_request")
    local current_target; current_target=$(gitlab_extract_target_branch "$merge_request")

    echo
    echo "-------------------------------------------------------------------"
    gitlab_title_undraft "$title"
    echo "-------------------------------------------------------------------"
    echo
    mr_actions "$source_branch" "$mr_summary" "$merge_request"

    # test merge status
    if [ "$merge_status" = "merged" ]; then
        echo_error "Merge request is already merged."
        echo_error
        return
    fi
    if [ "$merge_status" != "can_be_merged" ]; then
        echo_error "Merge request can not be merged. You probably need to rebase the branch and resolve conflicts."
        echo_error
        return
    fi

    # test open threads
    local unresolved_thread_count;
    unresolved_thread_count=$(gitlab_merge_request_threads "$project_url" "$mr_iid" | grep -c 'unresolved:true')

    if [ "$unresolved_thread_count" -gt 0 ]; then
        echo_error "There are $unresolved_thread_count unresolved threads. Please resolve them before merging."
        echo_error
        return
    fi

    if gitlab_title_is_draft "$title"; then
        echo_error "Merge request is a draft (work in progress)"

        if [ "$(confirm "Do you want to resolve draft status?")" != "yes" ]; then echo_error; return; fi

        echo -n "Resolving draft status... "
        local undraft_title; undraft_title=$(gitlab_title_undraft "$title")
        local mr_data;        mr_data=$(jq_build "title" "$undraft_title") || exit $?

        local result; result=$(gitlab_merge_request_update "${mr_iid}" "${mr_data}")

        if [ ! -z "$result" ]; then echo -e "OK\n";
        else echo_error; return; fi
    fi

    # Merge

    if [ "$(confirm "Do you want to merge '$source_branch' into '$current_target'?")" != "yes" ]; then echo; return; fi

    echo -n "Merging '$source_branch'... "
    local result; result=$(gitlab_merge_request_merge "${mr_iid}")
    if [ -z "$result" ]; then echo; return;
    else echo -e "OK\n"; fi

    # checkout target branch

    if [ "$(confirm "Do you want to checkout '$current_target' and pull changes?")" != "yes" ]; then echo; return; fi

    echo "$(colorize "git checkout $current_target && git pull --rebase" "lightgray")"
    git checkout "$current_target" && git pull --rebase
    echo

    # delete local branch

    if [ "$(confirm "Do you want to delete local branch '$source_branch'?")" != "yes" ]; then echo; return; fi

    echo "$(colorize "git branch -d $source_branch" "lightgray")"
    git branch -d "$source_branch"
    echo
}

function mr_menu
{
    gitlab_check_env

    local git_mr_menu_mode=show
    local git_mr_menu_update_all=0

    # Parse options
    args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            # Consume options
            up|update)   git_mr_menu_mode=update ;;
            st|status)   git_mr_menu_mode=status ;;
            -a|-A|--all) git_mr_menu_update_all=1 ;;
            # Default: conserve argument
            *) args+=("${1}") ;;
        esac
        shift
    done
    set -- "${args[@]}"

    local source_branch; source_branch=$(git_current_branch)
    local issue_code=${GIT_MR_CODE:-${1:-$(guess_issue_code "$source_branch")}}

    if [ -z "$issue_code" ]; then
      return
    fi

    # All non-closed merge requests for issue code
    local menu_items; menu_items=$(mr_menu_merge_requests "$issue_code")

    if [ -z "$menu_items" ]; then
        echo_error "No merge requests found for '$issue_code'."
        return
    fi

    case "$git_mr_menu_mode" in
        show) mr_menu_show "$menu_items" ;;
        update)
            if [ "$git_mr_menu_update_all" = "1" ]; then
                mr_menu_update_all "$menu_items"
            else
                mr_menu_update "$menu_items"
            fi
            ;;
        status) mr_menu_status "$issue_code" "$menu_items" ;;
    esac
}

function mr_ip
{
    [ -n "$GITLAB_CR_LABELS" ] || echo_error "GITLAB_CR_LABELS is not set"
    [ -n "$GITLAB_QA_LABELS" ] || echo_error "GITLAB_QA_LABELS is not set"
    [ -n "$GITLAB_OK_LABELS" ] || echo_error "GITLAB_OK_LABELS is not set"

    local source_branch=${1:-$(git_current_branch)}
    local issue_code=${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}

    mr_update_labels "${source_branch}" "${GITLAB_OK_LABELS},${GITLAB_QA_LABELS},${GITLAB_CR_LABELS}" ""

    if [ -n "$issue_code" ] \
    && [ -n "$JIRA_IP_ID" ] \
    && [ "$(confirm "Do you want to update the Jira ticket status to \"In Progress\"?")" = "yes" ]; then
        echo -n "Updating Jira ticket status... "

        jira_transition "$issue_code" "$JIRA_IP_ID" && echo -e "OK\n"
    fi
    if [ -z "$JIRA_IP_ID" ]; then echo_error "Set JIRA_IP_ID to be able to update Jira status\n"; fi
}

function mr_cr
{
    [ -n "$GITLAB_CR_LABELS" ] || echo_error "GITLAB_CR_LABELS is not set"
    [ -n "$GITLAB_QA_LABELS" ] || echo_error "GITLAB_QA_LABELS is not set"
    [ -n "$GITLAB_OK_LABELS" ] || echo_error "GITLAB_OK_LABELS is not set"

    local source_branch=${1:-$(git_current_branch)}
    local issue_code=${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}

    mr_update_labels "${source_branch}" "${GITLAB_OK_LABELS},${GITLAB_QA_LABELS}" "${GITLAB_CR_LABELS}"

    if [ -n "$issue_code" ] \
    && [ -n "$JIRA_CR_ID" ] \
    && [ "$(confirm "Do you want to update the Jira ticket status to \"Code Review\"?")" = "yes" ]; then
        echo -n "Updating Jira ticket status... "

        jira_transition "$issue_code" "$JIRA_CR_ID" && echo -e "OK\n"
    fi
    if [ -z "$JIRA_CR_ID" ]; then echo_error "Set JIRA_CR_ID to be able to update Jira status\n"; fi
}

function mr_qa
{
    [ -n "$GITLAB_CR_LABELS" ] || echo_error "GITLAB_CR_LABELS is not set"
    [ -n "$GITLAB_QA_LABELS" ] || echo_error "GITLAB_QA_LABELS is not set"
    [ -n "$GITLAB_OK_LABELS" ] || echo_error "GITLAB_OK_LABELS is not set"

    local source_branch=${1:-$(git_current_branch)}
    local issue_code=${GIT_MR_CODE:-$(guess_issue_code "$source_branch")}

    mr_update_labels "${source_branch}" "${GITLAB_OK_LABELS},${GITLAB_CR_LABELS}" "${GITLAB_QA_LABELS}"

    if [ -n "$issue_code" ] \
    && [ -n "$JIRA_QA_ID" ] \
    && [ "$(confirm "Do you want to update the Jira ticket status to \"Quality Assurance\"?")" = "yes" ]; then
        echo -n "Updating Jira ticket status... "

        jira_transition "$issue_code" "$JIRA_QA_ID" && echo -e "OK\n"
    fi
    if [ -z "$JIRA_QA_ID" ]; then echo_error "Set JIRA_QA_ID to be able to update Jira status\n"; fi
}

function mr_hook
{
    local git_dir; git_dir=$(git rev-parse --git-dir)
    local git_mr_dir; git_mr_dir="$(dirname "${BASH_SOURCE[0]}")"

    [ ! -d "${git_dir}/hooks" ] && mkdir "${git_dir}/hooks"

    find "${git_mr_dir}/hooks" -type f -print0 | while read -d $'\0' hook; do
        local hook_name; hook_name="$(basename $hook)"
        echo "Linking hook: ${hook_name}"
        ln -sf "$hook" "${git_dir}/hooks/${hook_name}"
    done
}

function usage
{
    local b; b="$(printf '\e[1m')"
    local u; u="$(printf '\e[4m')"
    local r; r="$(printf '\e[0m')"

    cat << EOF
${b}NAME${r}
       ${u}git-mr${r} - Manage a Gitlab merge request description, with link to Jira ticket and current branch commit list

${b}SYNOPSIS${r}
       ${u}git${r} ${u}mr${r} [OPTION...]          [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  open    [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  status  [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  update  [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  merge   [BRANCH]

       ${u}git${r} ${u}mr${r} [OPTION...]  menu                 [SEARCH_TERM]
       ${u}git${r} ${u}mr${r} [OPTION...]  menu update [--all]  [SEARCH_TERM]
       ${u}git${r} ${u}mr${r} [OPTION...]  menu status          [SEARCH_TERM]

       ${u}git${r} ${u}mr${r} [OPTION...]  (ip|cr|qa)  [BRANCH]
       ${u}git${r} ${u}mr${r} [OPTION...]  undraft     [BRANCH]

       ${u}git${r} ${u}mr${r} hook

       ${u}git${r} ${u}mr${r} base
       ${u}git${r} ${u}mr${r} code

${b}ARGUMENTS${r}
       BRANCH
           Force merge request source branch.
           Defaults to current branch.

       SEARCH_TERM
           Term searched in merge requests titles to build menu.
           Defaults to Jira issue code guessed from branch name.

${b}OPTIONS${r}

       -c, --code   ISSUE_CODE
           Force issue code.

       -t, --target TARGET_BRANCH
           Force target branch.

       -v
           Verbose output (displays called API URLs).

       -y
           Bypass confirmation prompts ("yes").

       -e
           Use full commit messages in description ("extended", for \`git mr [open|update]\`).
           You can also set GIT_MR_EXTENDED=1 in your environment variables to always use extended commit descriptions.

       -n  
           Add new section in description for new commits (for \`git mr update\`)

       -a, --all
           Update all merge requests (for \`git mr menu update\`).

       -h
           Show this help.

${b}CONFIGURATION${r}

       You need to configure the following environment variables:

           export JIRA_USER="user.name@mycompany.com"
           export JIRA_INSTANCE="mycompany.atlassian.net"
           export JIRA_TOKEN="abcdefghijklmnopqrstuvwx"
           export JIRA_CODE_PATTERN="[A-Z]{2,3}-[0-9]+"

           export GITLAB_DOMAIN="myapp.gitlab.com"
           export GITLAB_TOKEN="Zyxwvutsrqponmlkjihg"

       To create a Jira API Token, go to: https://id.atlassian.com/manage-profile/security/api-tokens
       (Account Settings -> Security -> API Token -> Create and manage API tokens)

       To create a Gitlab API Token, go to: https://myapp.gitlab.com/-/profile/personal_access_tokens?name=Git-MR+Access+token&scopes=api
       (Settings -> Access Tokens)

       Optional configuration variables:

           # Default labels for new merge requests
           export GITLAB_DEFAULT_LABELS="Review,My Team"

           # Check "Delete source branch" by default (defaults to 1)
           export GITLAB_DEFAULT_FORCE_REMOVE_SOURCE_BRANCH=1

           # Network timeout (in seconds, defaults to 5)
           export GIT_MR_TIMEOUT=5

           # Gitlab status labels (comma-separated, without spaces in between)
           export GITLAB_OK_LABELS="Validated,Accepted" # Labels removed on IP, CR or QA steps
           export GITLAB_CR_LABELS="Review"             # Labels set on CR step
           export GITLAB_QA_LABELS="Testing"            # Labels set on QA step

           # Jira status IDs
           export JIRA_IP_ID="xx" # "In Progress" status ID
           export JIRA_CR_ID="xx" # "Code Review" status ID
           export JIRA_QA_ID="xx" # "Quality Assurance" status ID

EOF
}


################################################################################
# Hardcoded constants
GITLAB_DRAFT_PREFIX="Draft"
GITLAB_DRAFT_PREFIXES=("WIP" "Draft")
MD_BOLD=${MD_BOLD="**"} # Markdown bold
MD_BR=${MD_BR="  "} # Markdown line break
GIT_MR_MENU_START=${GIT_MR_MENU_START:-"## Menu"}
GIT_MR_MENU_END=${GIT_MR_MENU_END:-"---------------------------------------------------------------------------------"}


################################################################################
# Run

# Exit if not running script directly (ex: when sourcing)
[ "$(basename "$0")" != 'git-mr' ] && return;

# Init

git rev-parse > /dev/null 2>&1 || exit_error 1 "Not a git repository"

if [ ! -x "$(command -v jq)" ]; then
    exit_error 2 "Git-MR requires jq [https://stedolan.github.io/jq/]"
fi


# Parse options
args=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -t|--target) GIT_MR_TARGET="$2"; shift ;;
        -c|--code)   GIT_MR_CODE="$2";   shift ;;

        -v|-V) GIT_MR_VERBOSE=1 ;;
        -y|-Y) GIT_MR_YES=1     ;;
        -e|-E) GIT_MR_EXTENDED=1 ;;
        -n|-N) GIT_MR_UPDATE_NEW_SECTION=1 ;;

        -h) usage; exit 0; ;;

        *) args+=("${1}") ;;
    esac
    shift
done
set -- "${args[@]}"


# Run
case $1 in

    help|usage) usage ;;

    o|op|open)   mr_open   "${@:2}" ;;
    s|st|status) mr_status "${@:2}" ;;
    u|up|update) mr_update "${@:2}" ;;
    m|mg|merge)  mr_merge  "${@:2}" ;;

    menu) mr_menu "${@:2}" ;;

    p|ip|IP) mr_ip "${@:2}" ;;
    r|cr|CR) mr_cr "${@:2}" ;;
    q|qa|QA) mr_qa "${@:2}" ;;

    undraft) gitlab_undraft "${@:2}" ;;

    hook) mr_hook ;;

    # Plumbing
    base) git_base_branch ;;
    code) guess_issue_code ;;

    *) mr_print "$@" ;;

esac


################################################################################
# Error code reference:
#
#   1   Not a git repository
#   2   jq is not installed
#   3   Git branch error
#
#  10   Gitlab request error
#  11   GITLAB_DOMAIN|GITLAB_TOKEN is not set
#  12   Unable to determine Gitlab project URL
#
#  20   Jira request error
#  21   JIRA_USER|JIRA_TOKEN|JIRA_INSTANCE is not set
#
